title,text
Installation,"Installation. # Installation !!! Info ""Platforms"" The AEA framework can be used on , and ."
Installation,"System Requirements. ,Alternatively: Use Docker: We also provide a Docker image with all the needed dependencies. 1. Pull the image: 2. Run the image with your current local directory mounted as a docker volume. This allows you to keep your agents local while working on them from within the docker container: === ""Linux and MacOs"" === ""Windows"" Once successfully logged into the docker container, you can follow the rest of the guide the same way as if not using docker."
Installation,"For Agent Development. ,Preliminaries: 1. Create a new working directory. Let's call it . This is where you will create your agent projects. 2. Inside , add an empty directory called . This is a local registry for your agents' components. You should now have the following directory structure: !!! tip ""Alternatively, clone a template repo:"" Instead of the above, you can clone the template repo as described in in the <a href=""../development-setup#approach-1"">development setup</a> guide. #### Virtual Environment Unless you are using the docker image, we highly recommend using a virtual environment so that your setup is isolated from the rest of your system. This prevents clashes and ensures consistency across dependencies. You can use any common virtual environment manager for Python, such as <a href=""https://pypi.org/project/pipenv/"" target=""_blank""></a> and <a href=""https://python-poetry.org/docs/#installation"" target=""_blank""></a>. If you do not have either, install one. Once installed, create a new virtual environment in the directory and enter it: === ""pipenv"" Use any <a href=""../install/#system-requirements"">Python version supported</a> in the command: === ""poetry"" ,Installation: The latest version of the Python implementation of the AEA Framework is: <a href=""https://pypi.org/project/aea/"" target=""_blank""> <img alt=""PyPI"" src=""https://img.shields.io/pypi/v/aea""> </a> !!! info ""Note"" If you are upgrading your AEA project from a previous version of the AEA framework, make sure you check out <a href=""../upgrading/"">the upgrading notes</a>. #### Using pip Install the AEA framework using pip: === ""bash/windows"" === ""zsh"" ??? tip ""Troubleshooting"" To ensure no cache is used, add to the installation command. #### Using pipx Install the AEA framework using pipx:"
Installation,"For Contributing to the AEA Framework. To contribute to the development of the framework or related tools (e.g. ACN), please refer to the <a href=""https://github.com/fetchai/agents-aea/blob/main/CONTRIBUTING.md"" target=""_blank"">Contribution</a> and <a href=""https://github.com/fetchai/agents-aea/blob/main/DEVELOPING.md"" target=""_blank"">Development</a> guides in our GitHub repository."
Installation,"Other Tools You Might Need. Depending on what you want to do, you might need extra tools on your system: - To use the Agent Communication Network (ACN) for peer-to-peer communication between agents (e.g. using the connection) you will need <a href=""https://go.dev/doc/install"" target=""_blank""> Golang 1.14.2 or higher</a>. - The framework uses <a href=""https://protobuf.dev"" target=""_blank"">Google Protocol Buffers</a> for message serialization. If you want to develop protocols, install the protobuf compiler on your system. The version you install must match the library installed with the project (see <a href=""https://github.com/fetchai/agents-aea/blob/main/pyproject.toml"" target=""_blank"">pyproject.toml</a>). - To update fingerprint hashes of packages, you will need the <a href=""https://docs.ipfs.tech/install/"" target=""_blank"">IPFS daemon</a>."
TAC External App,"TAC External App. # TAC External App !!! note This app is no longer maintained. The original TAC has its own <a href=""https://github.com/fetchai/agents-tac"" target=""_blank"">repo</a>. Follow the instructions below to build and run the TAC demo."
TAC External App,"Requirements. Make sure you are running <a href=""https://docs.docker.com/get-docker/"" target=""_blank"">Docker</a> and <a href=""https://docs.docker.com/compose/install/"" target=""_blank"">Docker Compose</a>."
TAC External App,"Quick Start. Clone the repo to include submodules. Check you have . If you don't have it, install it. Instructions are <a href=""https://pypi.org/project/pipenv/"" target=""_blank"">here</a>. Create and launch a virtual environment. Install the dependencies. Install the package. Run the launch script. This may take a while. The <a href=""https://github.com/fossasia/visdom"" target=""_blank"">Visdom</a> server is now running. The controller GUI at <a href=""http://localhost:8097"" target=""_blank"">http://localhost:8097</a> provides real time insights. In the Environment tab, make sure you have the environment selected. <img src=""../assets/visdom_ui.png"" alt=""AEA Visdom UI"" class=""center"">"
TAC External App,"Alternative Build and Run. In a new terminal window, clone the repo, build the sandbox, and launch it. In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. Click through to the <a href=""http://localhost:8097"" target=""_blank"">controller GUI</a>."
TAC External App,"Possible Gotchas. Stop all running containers before restart. To remove all images, run the following command."
Trade between Two AEAs,"Trade between Two AEAs. # Trade between Two AEAs This guide is a step-by-step introduction to building AEAs that advertise their static and dynamic data, find other AEAs with required data, negotiate terms of trade, and carry out trades via ledger transactions. If you simply want to run the resulting AEAs <a href=""../generic-skills"">go here</a>."
Trade between Two AEAs,"Dependencies (Required). Follow the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start."
Trade between Two AEAs,"Reference Code (Optional). This step-by-step guide goes through the creation of two AEAs which are already developed by Fetch.ai. You can get the finished AEAs, and compare your code against them, by following the next steps:"
Trade between Two AEAs,"Simplification Step. To keep file paths consistent with the reference code, we suggest you initialize your local author as for the purpose of this demo only:"
Trade between Two AEAs,"Generic Seller AEA. ,Step 1: Create the AEA: Create a new AEA by typing the following command in the terminal: Our newly created AEA is inside the current working directory. Let’s create our new skill that will handle the sale of data. Type the following command: The command creates the correct structure for a new skill inside our AEA project. You can locate the newly created skill under the ""skills"" folder (), and it must contain the following files: - - - - - ,Step 2: Create the Behaviour: A <a href=""../api/skills/base#behaviour-objects""></a> class contains the business logic specific to actions initiated by the AEA, rather than reactions to other events. Open the file () and replace the stub code with the following: This <a href=""../api/skills/behaviours#tickerbehaviour-objects""></a> registers (see method) and de-registers (see method) our AEA’s service on the <a href=""../simple-oef"">SOEF search node</a> at regular tick intervals (here 60 seconds). By registering, the AEA becomes discoverable to other AEAs. In , prior to registrations, we send a message to the ledger connection to check the account balance for the AEA's address on the configured ledger. ,Step 3: Create the Handler: So far, we have tasked the AEA with sending register/unregister requests to the <a href=""../simple-oef"">SOEF search node</a>. However at present, the AEA has no way of handling the responses it receives from the search node, or in fact messages sent by any other AEA. We have to specify the logic to negotiate with another AEA based on the strategy we want our AEA to follow. The following diagram illustrates the negotiation flow that we want this AEA to use, as well as interactions with a search node and the blockchain between a and a . In our case, is the in the above figure. Let us now implement a <a href=""../api/skills/base#handler-objects""></a> to deal with incoming messages. Open the file () and replace the stub code with the following: The code above contains the logic for handling received by the AEA. We use (more on this <a href=""../generic-skills-step-by-step/#step-5-create-the-dialogues"">below</a>) to keep track of the progress of the negotiation dialogue between the AEA and the AEA. In the above method, we first check if a received message belongs to an existing dialogue or if we have to create a new dialogue (the part). Once this is done, we break down the AEA's response to each type of negotiation message, as indicated by the message's performative (the part). Therefore, we implement the AEA's response to each negotiation message type in a different handler function. Below the unused function, we continue by adding the following function: The above code handles an unidentified dialogue by responding to the sender with a containing the appropriate error information. The next code block handles (call-for-proposal) negotiation messages. Paste the following code below the function: The above code sends a message back to the buyer as a response to its if the requested services match our seller agent's supplied services, otherwise it will respond with a message. The next code-block handles the decline message we receive from the buyer. Add the following code below the function: If we receive a decline message from the buyer we close the dialogue and terminate this conversation with . Alternatively, we might receive an message. In order to handle this option add the following code below the function: When accepts the we send it and sends an message, we have to respond with another message () to match the acceptance of the terms of trade and to inform the buyer of the address we would like it to send the funds to. Lastly, we must handle an message, which the buyer uses to inform us that it has indeed sent the funds to the provided address. Add the following code at the end of the file: In the above code, we check the message. If it contains a transaction digest, then we verify that the transaction matches the proposal the buyer accepted. If the transaction is valid and we received the funds, then we send the data to the buyer. Otherwise, we do not send the data. The remaining handlers are as follows: The deals with from the ledger connection and the handles from the SOEF connection. ,Step 4: Create the Strategy: Next, we are going to create the strategy that we want our AEA to follow. Rename the file () to and replace the stub code with the following: keyvaluekeyvaluekeyvalue In the above code snippet, we initialise the strategy class by trying to read the variables specific to the strategy from a YAML configuration file. If any variable is not provided, some default values will be used. The following properties and methods deal with different aspects of the strategy. They should be relatively self-descriptive. Add them under the initialization of the strategy class: The helper private function is where we read data from a sensor or if there are no sensor we use some default data provided (see the property). ,Step 5: Create the Dialogues: To keep track of the structure and progress of interactions, including negotiations with a buyer AEA and interactions with search nodes and ledgers, we use dialogues. Create a new file in the skill folder () and name it . Inside this file add the following code: The class contains negotiation dialogues with each AEA (and other AEAs) and exposes a number of helpful methods to manage them. This helps us match messages to the dialogues they belong to, access previous messages and enable us to identify possible communications problems between the AEA and the AEA. It also keeps track of the data that we offer for sale during the proposal phase. The class extends , which itself derives from the base <a href=""../api/protocols/dialogue/base#dialogues-objects""></a> class. Similarly, the class extends which itself derives from the base <a href=""../api/protocols/dialogue/base#dialogue-objects""></a> class. To learn more about dialogues have a look <a href=""../protocol"">here</a>. ,Step 6: Update the YAML Files: Since we made so many changes to our AEA we have to update the (at ). Make sure you update your with the following configuration: We must pay attention to the models and in particular the strategy’s variables. Here we can change the price we would like to sell each data reading for, or the currency we would like to transact with. Lastly, the dependencies are the third party packages we need to install in order to get readings from the sensor. Finally, we fingerprint our new skill: This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed."
Trade between Two AEAs,"Generic Buyer AEA. ,Step 1: Create the AEA: In a new terminal, create a new AEA by typing the following command in the terminal: Our newly created AEA is inside the current working directory. Let’s create a new skill for purchasing data. Type the following command: This command creates the correct structure for a new skill inside our AEA project. You can locate the newly created skill under the skills folder () and it must contain the following files: - - - - - ,Step 2: Create the Behaviour: Open the file () and replace the stub code with the following: This <a href=""../api/skills/behaviours#tickerbehaviour-objects""></a> will send a search query to the <a href=""../simple-oef"">SOEF search node</a> at regular tick intervals. ,Step 3: Create the Handler: So far, the AEA is tasked with sending search queries to the <a href=""../simple-oef"">SOEF search node</a>. However, currently the AEA has no way of handling the responses it receives from the SOEF or messages from other agents. Let us now implement <a href=""../api/skills/base#handler-objects""></a> to deal with the expected incoming messages. Open the file () and add the following code (replacing the stub code already present in the file): You will see that we are following similar logic to the when we develop the ’s side of the negotiation. First, we create a new dialogue and store it in the dialogues class. Then we are checking what kind of message we received by checking its performative. So lets start creating our handlers: The above code handles messages referencing unidentified dialogues and responds with an error message to the sender. Next we will handle the message received from the AEA: When we receive a proposal, we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable, we respond with a message. Otherwise, we send an message to the seller. The next code-block handles the message that we may receive from the seller as a response to our or messages: The above code terminates each dialogue with the specific AEA and stores the state of the terminated dialogue (whether it was terminated after a or an ). If AEA wants to move on with the sale, it will send a message. In order to handle this we add the following code: The first thing we are checking is if we enabled our AEA to transact with a ledger. If so, we add this negotiation to the queue of transactions to be processed. If not, we simulate non-ledger payment by sending an to the seller that the payment is done (say via bank transfer). Lastly, we need to handle messages. This is the message that will have our data: We now need to add handlers for messages received from the and the <a href=""../simple-oef"">SOEF search node</a>. We need one handler for each type of protocol we use. To handle the messages in the protocol used by the <a href=""../simple-oef"">SOEF search node</a> we add the following code in the same file (): When we receive a message from the <a href=""../simple-oef"">SOEF search node</a> of a type , we are passing the details to the relevant handler method. In the function, we are checking that the response contains some agents, and we stop the search if it does. We pick our first agent and send a message. The last handlers we need are the and the . These handlers are responsible for that we receive from the , and that we receive from the ledger connection, respectively. ,Step 4: Create the Strategy: We are going to create the strategy that we want our AEA to follow. Rename the file (in ) to and replace the stub code with the following: Similar to the seller AEA, we initialize the strategy class by trying to read the strategy variables from the YAML file, and if not possible, use some default values. In the following snippet, the two methods after the properties are related to the OEF search service. Add this snippet under the initialization of the strategy class: The following code block checks if the proposal that we received is acceptable according to a strategy: The method in the following code block checks if we can afford the transaction based on the funds we have in our wallet on the ledger. The rest of the methods are self-explanatory. ,Step 5: Create the Dialogues: As mentioned during the creation of the seller AEA, we should keep track of the various interactions an AEA has with others and this is done via dialogues. Create a new file and name it (in ). Inside this file add the following code: The various dialogues classes in the above code snippet store dialogues with other AEAs, services and components, (e.g. SOEF search node via the connection, ledgers via the connection and the decision maker). They expose useful methods to manipulate these interactions, access previous messages, and enable us to identify possible communications problems between and AEAs. ,Step 6: Update the YAML Files: After making so many changes to our skill, we have to update the configuration file so it reflects our newly created classes, and contains the values used by the strategy. Make sure contains the following configuration: We must pay attention to the models and the strategy’s variables. Here we can change the price we would like to buy each reading at, the maximum transaction fee we are prepared to pay, and so on. Finally, we fingerprint our new skill: This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed."
Trade between Two AEAs,"Run the AEAs. ,Create Private Keys: For each AEA, create a private key: Next, create a private key to secure the AEA's communications: Finally, certify the key for use by the connections that request that: ,Update the AEA Configurations: In both AEAs run: ,Fund the Buyer AEA: Create some wealth for your buyer on the Fetch.ai testnet (this operation might take a while). ,Run Seller AEA: Add the remaining packages for the seller AEA, then run it: Once you see a message of the form take note of the address. #### Run Buyer AEA Add the remaining packages for the buyer AEA: Then, update the configuration of the buyer AEA's P2P connection: where is replaced accordingly. Then run the buyer AEA: You will see that the AEAs negotiate and then transact using the Dorado testnet."
Trade between Two AEAs,"Delete the AEAs. When you are done, go up a level and delete the AEAs."
Trade between Two AEAs,"Next Steps. ,Recommended: We recommend you build your own AEA next. There are many helpful guides and demos in the documentation, and a developer community on <a href=""https://discord.com/invite/btedfjPJTj"" target=""_blank"">Discord</a>. Speak to you there!"
Front-End Integration,"Front-End Integration. # Front-End Integration This page lays out two options for connecting a front-end to an AEA. The following diagram illustrates these two options. <img src=""../assets/http-integration.jpg"" alt=""How to connect front-end to your AEA"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:80%;"">"
Front-End Integration,"Case 1. The first option is to create a connection that handles incoming requests from a REST API. In this scenario, the REST API communicates with the AEA and requests are handled by the connection package. The REST API should send CRUD requests to the connection () which translates these into Envelopes to be consumed by the correct skill."
Front-End Integration,"Case 2. The second option is to create a front-end comprising a stand-alone with a connection (). In this scenario the <a href=""../acn"">Agent Communication Network</a> can be used to send Envelopes from the AEA to the front-end."
Generating Protocols,Generating Protocols. # Generating Protocols
Generating Protocols,"How to Run. ,Full Mode vs Protobuf Only Mode: Currently, the generator can operate in _full mode_ for Python, creating a complete protocol package (files 1 to 7 above) from a protocol specification. The generator also has a _protobuf only mode_ which only creates the protocol buffer schema and implementation files (files 5 and 6 above). The languages supported in the _protobuf only mode_ and their respective ids are below: - go: - c++: - java: - c&#35;: - ruby: - objective-c: - javascript: To use the generator in protobuf only mode for any of the above languages: where is a language id. The protocol buffer compiler requires a plugin to generate Go code. Install it with: !!! note Note the protocol buffer compiler that the generator uses requires a plugin to produce code. Follow <a href=""../protocol-generator/#protocol-specification"">this instruction</a>."
Generating Protocols,"Protocol Specification. ,Basic Protocol Detail and Messages Syntax: The first YAML document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol. The allowed fields and what they represent are: - : The name of the protocol (written in <a href=""https://en.wikipedia.org/wiki/Snake_case"" target=""_blank"">snake_case</a>) - : The creator of the protocol - : The current version of the protocol - : Licensing information - : The version(s) of the framework that support this protocol. The format is described <a href=""https://www.python.org/dev/peps/pep-0440/"" target=""_blank"">here</a>. - : A short description of the protocol - : The id which identifies the protocol for over-the-wire transport. This id is decoupled from the () which is tied to the Python implementation. All of the above fields are mandatory and each is a key/value pair, where both key and value are YAML strings. Additionally, the first YAML document of a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, it must contain another mandatory field which defines the set of _performatives_ valid under this protocol, and a set of _contents_ for each performative. A _performative_ defines the _type_ of a message (e.g. propose, accept) and has a set of _contents_ (or parameters) of varying types. The format of the is as follows: is a dictionary, where each key is a **unique** _performative_ (YAML string), and the value is a _content_ dictionary. If a performative does not have any content, then its content dictionary is empty, for instance and in the specification above. A content dictionary in turn has key/value pairs, where each key is the name of a content (YAML string) and the value is its <a href=""../protocol-generator/#types"">type</a> (YAML string). For example, the (short for 'call for proposal') performative has one content whose name is and whose type is . #### Types The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: - Custom types are prepended with and their format is described using regular expression in the table below. - Primitive types are prepended with . There are different categories of primitive types. For example, such as integers and booleans, such as sets and lists, and so on. Primitive types are compositional: - For example, consider under , i.e. an unordered collection of elements without duplicates. A describes the type of its elements (called ""sub-type"") in square brackets. The subtype of a must be a (e.g. , ). - In describing the format of types, between two subtypes should be treated as ""or"". For example, the subtype of a is either a , , , or . A multi type denotes an ""or"" separated set of subtypes. For example, a content whose type is specified as should either be or . An optional type assigned to a content means the content's existence is optional, but if it is present, its type must match 's subtype. | Type | Code | Format | Example | In Python | |-------------------------------------|---------|---------------------------------------------------------------|------------------------------------------|------------------------------------| | Custom types<sup>1</sup> | | | | Custom Class | | Primitive types | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | Primitive collection types | | | | | | | | | | <sup>*</sup> | | Primitive mapping types<sup>2</sup> | | | | | | Multi types | | | | | | Optional types | | | | | &#42; This is how variable length tuples containing elements of the same type are declared in Python; see <a href=""https://docs.python.org/3/library/typing.html#typing.Tuple"" target=""_blank"">here</a>. ,Protocol Buffer Schema: Currently, the AEA framework does not officially support describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required serialisation logic must be provided manually. Therefore, if any of the contents declared in is of a custom type, the specification must then have a second YAML document, containing the protocol buffer schema code for each custom type. You can see an example of the second YAML document in the above protocol specification. ,Dialogues: You can optionally specify the structure of dialogues conforming to your protocol in a third YAML document in the specification. The allowed fields and what they represent are: - : The list of initial performatives - : The reply structure of speech-acts - : The list of terminal performatives - : The roles of players participating in a dialogue - : The possible outcomes a terminated dialogue. - : whether to keep or drop a terminated dialogue. When a storage backend is configured, the dialogues will be persisted in storage when kept. All of the above fields are mandatory. is a YAML list, containing the performatives which can be used to start a dialogue. specifies for every performative, what its valid replies are. If a performative is a valid reply to another , this means a message with performative can target a message whose performative is . is a YAML dictionary, where the keys are the performatives (YAML string) defined in . For each performative key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to are and . is a YAML list, containing the performatives which terminate a dialogue. Once any of these performatives are used in a dialogue, the dialogue is terminated and no other messages may be added to it. is a YAML set, containing the roles players participating in dialogues can take. may contain one or two roles, each role being a YAML string. If there are two roles, each participant has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is only one role, then both participants in a dialogue have this same role. lists the final states a terminated dialogue may have. is a YAML list of strings. has a boolean value and specifies whether the terminated dialogues of this protocol are to be kept or discarded."
Generating Protocols,"Design Guidelines. ,Notes: 1. Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. _ Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification. - Once the generator is called, it produces a module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer. - Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialized/deserialized. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language). 2. Currently, the first element in cannot be a , or . This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint. 3. In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type ) has been set or not (see discussion <a href=""https://github.com/protocolbuffers/protobuf/issues/1606"" target=""_blank"">here</a>). In proto3, all optional fields are assigned a default value (e.g. for integers types, for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found. 4. Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserializing values of contents."
Generating Protocols,"Demo Instructions. First, create a new AEA project: Second, run the generator on the sample specification: This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator."
AEA and Web Frameworks,"AEA and Web Frameworks. # AEA and Web Frameworks The AEA framework borrows several concepts from popular web frameworks like <a href=""https://www.djangoproject.com/"" target=""_blank"">Django</a> and <a href=""https://rubyonrails.org/"" target=""_blank"">Ruby on Rails</a>."
AEA and Web Frameworks,MVC. 
AEA and Web Frameworks,"Comparison with the AEA Framework. The AEA framework is based on <a href=""https://en.wikipedia.org/wiki/Asynchronous_communication"" target=""_blank"">asynchronous messaging</a> and other <a href=""../agent-oriented-development"" target=""_blank"">agent-oriented development assumptions</a>. Hence, there is not a direct one-to-one relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make quick progress in the AEA framework, in particular the development of : - <a href=""../api/skills/base#handler-objects""></a>: receives messages for the protocol it is registered against and is supposed to handle these messages. Handlers are the reactive parts of a skill and can be thought of as similar to the in MVC. They can also send new messages. - <a href=""../api/skills/base#behaviour-objects""></a>: a behaviour encapsulates proactive components of the agent. Since web apps do not have any goals or intentions, they do not proactively pursue an objective. Therefore, there is no equivalent concept in MVC. Behaviours also can, but do not have to, send messages. - <a href=""../api/skills/tasks#task-objects""></a>: they are meant to deal with long-running executions and can be thought of as the equivalent of background tasks in traditional web apps. - <a href=""../api/skills/base#model-objects""></a>: they implement business logic and data representation, and as such, they are similar to the in MVC. <img src=""../assets/skill-components.jpg"" alt=""AEA Skill Components"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:80%;""> The concept is probably best compared to the of a given in the AEA framework. Whilst views represent information to the client, messages represent information sent to other agents, other agent components and services."
AEA and Web Frameworks,"Next Steps. We recommend you continue with the next step in the 'Getting Started' series: - <a href=""../skill-guide"">Build a skill for an AEA</a>"
Generic Storage,Generic Storage. # Generic Storage The AEA generic storage: description and usage.
Generic Storage,AEA Generic Storage. AEA generic storage allows AEA skill's components to store data permanently and use it any time. The primary scenario: to save AEA data on shutdown and load back on startup. Generic storage provides an API for general data manipulation in key-object style.
Generic Storage,Configuration. Storage is enabled by providing in the agent configuration () an optional . The storage URI consists of the backend name and string data provided to selected backend. The storage URI schema is Example: tells the AEA to use SQLite backend and store data in . Supported backends: - SQLite - bundled with python simple SQL engine that uses file or in-memory storage.
Generic Storage,"Dialogues and Storage Integration. ,Keep Terminal State Dialogues: The Dialogues class has the optional boolean argument which specifies whether a dialogue which has reached its terminal state is kept in memory or not. If is , dialogues that reach a terminal state are removed from memory and can not be used anymore. If is , dialogues that reach a terminal state are kept in memory or storage (if configured). If storage is configured, all dialogues in memory are stored on agent stop and restored on agent start. It is useful to save memory with terminated dialogues that will (possibly) be never used again. Default behaviour on keep terminals state dialogues is set according to the protocol specification but can be set explicitly with skill configuration section. Skill configuration to keep terminated dialogues for . Example: ,Dialogues Dump/Restore on Agent Restart: If storage is enabled then all the dialogues present in memory will be stored on agent's teardown and loaded on agent's start. ,Offload Terminal State Dialogues: If keep options is set and storage is available dialogues in terminal state will be dumped to generic storage and removed from memory. This option helps to save memory and handle terminated dialogues with the same functionality as when they are kept in memory. All the active dialogues will be stored and loaded during agent restart. All the terminated offloaded dialogues will stay in storage on agent restart. To enable dialogues offloading has to be enabled and storage configured."
Generic Storage,"Manual Usage with Skill Components. Handlers, Behaviours and Models are able to use storage if enabled. Storage is available with skill context: if is not None, storage is enabled and ready to use. Generic storage consists of two parts: objects and collections. Objects consist of the (unique string) and object body. The object body is any JSON friendly python data type: , , , , , . Collection is a group of the objects, objects data types can vary in the same collection. Collection name is name consists of letters, numbers and . To get/put specific object collection instance should be used. Collection instance provide set of methods to handle data objects. List of collection methods: Simple behaviour example: It saves the string of the first act and print it to stdout. Please, pay attention: object is not JSON friendly and can not be stored directly. it should be transformed to or string before put into the storage."
Connections,"Connections. # Connections A <a href=""../api/connections/base#connection-objects""></a> provides an interface for the agent to connect with entities in the outside world. Connections wrap SDKs or APIs and provide interfaces to networks, ledgers and other services. As such, a connection is concerned with I/O bound and continuously connected operations. Where necessary, a connection is responsible for translating between the framework specific <a href=""../protocol"">protocol</a> (an <a href=""../api/mail/base#envelope-objects""></a> with its contained <a href=""../api/protocols/base#message-objects""></a>) and the external service or third-party protocol (e.g. ). Hence, there are two roles for connections: wrapper and transport connection. The transport connection is responsible to delivering AEA envelopes. The messages constructed or received by a connection are eventually processed by one or several <a href=""../skill"">skills</a> which deal with handling and generating messages related to a specific business objective. <img src=""../assets/multiplexer.png"" alt=""Multiplexer of an AEA"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:50%;""> An can interact with multiple connections at the same time via the <a href=""../api/connections/base#connection-objects""></a>. Connections are passive in terms of multiplexer interactions (its methods are called by the Multiplexer), but they can run their own asynchronous or threaded tasks. The maintains an <a href=""../api/multiplexer#inbox-objects""></a> and <a href=""../api/multiplexer#outbox-objects""></a>, which are, respectively, queues for incoming and outgoing envelopes and their contained messages."
Connections,"Developing your Connection. ,Primary Methods to Develop - Asynchronous Connection Interface: The developer needs to implement four public coroutines: - The coroutine implements the setup logic required to be performed for the connection when it is initially launched. The coroutine is called by the AEA framework once when the agent is being started. - The coroutine implements the teardown logic required to be performed for the connection when it is eventually stopped. The coroutine is called by the AEA framework once when the agent is being stopped. - The coroutine is called by the AEA framework each time the handles an outgoing envelope specified to be handled by this connection. The coroutine must implement the processing of the envelope leaving the agent. - The coroutine is continuously called by the AEA framework. It either returns or an envelope. The coroutine must implement the logic of data being received by the agent, and if necessary, its translation into a relevant protocol. The framework provides a demo connection which implements an I/O reader and writer to send and receive messages between the agent and a local file. To gain inspiration and become familiar with the structure of connection packages, you may find it useful to check out , or connections. The latter two connections are for external clients to connect with an agent, and for the agent to connect with external servers, respectively. ,Primary Methods to Develop - Sync Connection Interface: The <a href=""../api/connections/base#connection-objects""></a> uses executors to execute synchronous code from the asynchronous context of the in executors/threads, which are limited by the amount of configured workers. The asynchronous methods , and are converted to callbacks which the developer implements: - - - All of these methods will be executed in the executor pool. Every method can create a message by putting it into the thread/asynchronous friendly queue that is consumed by the . The coroutine has no direct equivalent. Instead, the developer implements a method which runs synchronously in the background."
Connections,"Configuration. Options The file contains a number of fields that must be edited by the developer of the connection: - specifies the list of other connection this connection depends on - specifies the list of protocols this connection depends on - needs to match the name of the connection class in - can contain arbitrary configuration information which is made available in the constructor of the connection as keyword arguments () - lists the protocols which cannot be used in this connection - lists the protocols which this connection is restricted to be used by - lists any Python dependencies of the connection package - specifies whether this connection is only used as an abstract base class - lists certification requests of the connection (see <a href=""../por"">proof of representation</a> for details)"
Trust Minimisation,"Trust Minimisation. # Trust Minimisation AEA applications have different requirements for _trustlessness_ or _trust minimisation_. For example, using the AEA <a href=""../weather-skills/"">weather skills demo</a> _without_ ledger payments means that the client has to trust the weather station to send the weather data it purchased and that this data is in fact valid. Similarly, the weather station must trust that the client somehow sends the payment amount to which they agreed. A step-up, if you run the <a href=""../weather-skills/"">weather skills demo</a> with a ledger (e.g. Fetch.ai or Ethereum) then the client must still trust that the weather station sends valid data. However, all payment transactions are executed via the public ledger. This means the weather station no longer needs to trust the client for payment and can verify whether the transactions take place on the public ledger. We can further minimise trust requirements by incorporating a third party as an <a href=""https://en.wikipedia.org/wiki/Escrow"" target=""_blank"">arbitrator or escrow</a> implemented in a <a href=""https://en.wikipedia.org/wiki/Smart_contract"" target=""_blank"">smart contract</a> to further reduce trust requirements. However, in the current weather skills demo, there are limits to trustlessness as the station ultimately offers unverifiable data. Another example of minimising trust, is applications with (non-fungible) token transactions involving <a href=""https://dl.acm.org/doi/10.1145/3212734.3212736"" target=""_blank"">atomic swaps</a> where trustlessness is clearly satisfied (e.g. in the <a href=""../tac-skills-contract/"">TAC demo</a>)."
TAC Skills,TAC Skills. # TAC Skills The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game. There are two types of AEAs: - The which coordinates the game. - The AEAs which compete in the game. The AEAs trade tokens with each other to maximize their utility.
TAC Skills,"Discussion. The scope of this specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. Another AEA has the role of the controller, responsible for calculating the revenue for each participant and checking if the transaction messages are valid. Transactions are settled with the controller agent rather than against a public ledger."
TAC Skills,"Communication. This diagram shows the communication between two AEAs and the controller. In this case, we have an AEA in the role of the seller, referred to as . We also have an AEA in the role of the buyer, referred to as . During a given TAC, an AEA can be in both roles simultaneously in different bilateral interactions. In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them."
TAC Skills,"Option 1: AEA Manager Approach. ,Preparation Instructions: Install the <a href=""https://aea-manager.fetch.ai"" target=""_blank"">AEA Manager</a>. ,Demo Instructions: The following steps assume you have launched the AEA Manager Desktop app. 1. Add a new AEA called with public id . 2. Add another new AEA called with public id . 3. Add another new AEA called with public id . 4. Navigate to the settings of and under update to the time you want TAC to begin (e.g. 2 minutes in the future) 5. Run the AEA. Navigate to its logs and copy the multiaddress displayed. Stop the . 6. Navigate to the settings of and under update as follows (make sure to replace the placeholder with the multiaddress): 7. Navigate to the settings of and under update as follows (make sure to replace the placeholder with the multiaddress): 8. You may add more participants by repeating steps 3 (with an updated name) and 6 (bumping the port numbers. See the difference between steps 5 and 6). 9. Run the , then and (and any other participants you added). In the 's log, you should see the details of the transactions participants submit as well as changes in their scores and holdings. In participants' logs, you should see the agents trading."
TAC Skills,Option 2: CLI Approach. 
TAC Skills,Preparation Instructions. 
TAC Skills,"Demo Instructions. ,Create TAC Controller AEA: In the root directory, fetch the controller AEA: ??? note ""Alternatively, create from scratch:"" The following steps create the controller from scratch: ,Create the TAC Participant AEAs: In a separate terminal, in the root directory, fetch at least two participants: ??? note ""Alternatively, create from scratch:"" In a separate terminal, in the root directory, create at least two tac participant AEAs: Build participant one: Then, build participant two: ,Add Keys for All AEAs: Create the private key for the AEA for Fetch.ai : Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: ,Update the Game Parameters in the Controller: Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least two minutes in the future): To set the registration time, you may find handy the following command: ,Update the Connection Parameters: Briefly run the controller AEA: Once you see a message of the form take note of the address. (Alternatively, use to retrieve the address.) Then, in the participant one, run this command (replace with the correct value as described above): Do the same in participant two (beware of the different port numbers): This allows the TAC participants to connect to the same local agent communication network as the TAC controller. ,Run the AEAs: First, launch the : The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch both the TAC agents as follows from the root directory: You may want to try option in order to run the agents in the same process. ,Cleaning up: When you're finished, delete your AEAs:"
