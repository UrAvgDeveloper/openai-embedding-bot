title,text
Integration,"Integration. # Integration If you want to use Wasm in your own app, here is how you can get this working quickly and easily. First, check to make sure you fit the pre-requisites, then integrate the module as described below, and finally, you can add custom messages and queries to your custom Go/SDK modules, exposing them to any chain-specific contract."
Integration,"Prerequisites. The pre-requisites of integrating into your custom app is to be using a compatible version of the Cosmos SDK, and to accept some limits to the hardware it runs on. | fetchd | Cosmos SDK | |:-----:|:----------:| | v0.7 | v0.38 | | v0.8 | v0.38 | We currently only support Intel/AMD64 CPUs and OSX or Linux. For Linux, the standard build commands work for systems (Ubuntu, Debian, CentOS, etc). If you wish to compile for a based system (like alpine), you need to compile a static library go-cosmwasm locally and compile go with the build tag. Or just use the Dockerfile at ./Dockerfile, which builds a static go binary in an alpine system. This limit comes from the Rust dll we use to run the wasm code, which comes from at https://github.com/CosmWasm/go-cosmwasm. There are open issues for adding ARM support at https://github.com/CosmWasm/go-cosmwasm/issues/53, and adding Windows support at https://github.com/CosmWasm/go-cosmwasm/issues/28. However, these issues are not high on the roadmap and unless you are championing them, please count on the current limits for the near future."
Integration,"Quick Trial. The simplest way to try out CosmWasm is simply to run out of the box, and focus on writing, uploading, and using your custom contracts. There is plenty that can be done there, and lots to learn. Once you are happy with it and want to use a custom Cosmos SDK app, you may consider simply forking . *I highly advise against this*. You should try one of the methods below."
Integration,"Integrating fetchd. ,As external module: The simplest way to use is just to import and wire it up in . You now have access to the whole module and you custom modules running side by side. (But the CosmWasm contracts will only have access to and ... more below on customization at #Adding-Custom-Hooks). The requirement here is that you have imported the standard sdk modules from the Cosmos SDK, and enabled them in . If so, you can just look at at https://github.com/fetchai/fetchd/blob/master/app/app.go# for how to do so (just search there for lines with ). ,Copied into your app: Sometimes, however, you will need to copy into your app. This should be in limited cases, and makes upgrading more difficult, so please take the above path if possible. This is required if you have either disabled some key SDK modules in your app (eg. using PoA not staking and need to disable those callbacks and feature support), or if you have copied in the core modules from the Cosmos SDK into your application and customized them somehow. In either case, your best approach is to copy the module from the latest release into your application. Your goal is to make **minimal changes** in this module, and rather add your customizations in a separate module. This is due to the fact that you will have to copy and customize from upstream on all future releases, and this should be as simple as possible. If, for example, you have forked the standard SDK libs, you just want to change the imports (from eg. to ), and adjust any calls if there are compiler errors due to differing APIs (maybe you use Decimals not Ints for currencies?). By the end of this, you should be able to run the standard CosmWasm contracts in your application, alongside all your custom logic."
Integration,"Adding custom hooks. ,Calling contracts from native code: This is perhaps the easiest part. Let's say your native exchange module wants to call into a token that lives as a CosmWasm module. You need to pass the into your . If you know the format for sending messages and querying the contract (exported as json schema from each contract), and have a way of configuring addresses of supported token contracts, your exchange code can simply call with a properly formatted message to move funds, or to check balances. If you look at the unit tests in at https://github.com/fetchai/fetchd/tree/master/x/wasm/internal/keeper, it should be pretty straightforward. ,Extending the Contract Interface: If you want to let the contracts access your native modules, the first step is to define a set of Messages and Queries that you want to expose, and then add them as and variants. You can see an example of the bindings for Terra at https://github.com/CosmWasm/terra-contracts/tree/master/packages/bindings. Once you have those bindings, use them to build a simple contact using much of the API at https://github.com/CosmWasm/terra-contracts/tree/master/contracts/maker. Don't worry too much about the details, this should be usable, but mainly you will want to upload it to your chain and use for integration tests with your native Cosmos SDK modules. Once that is solid, then add more and more complex contracts. You will then likely want to add a package so you can provide mocks for the functionality of your native modules when unit testing the contracts (provide static data for exchange rates when your contracts query it). You can see an example of mocks for Terra contracts at https://github.com/CosmWasm/terra-contracts/tree/master/packages/mocks. What these three steps provide is basically a chain-specific extension to the CosmWasm contract SDK. Any CosmWasm contract can import your library (bindings and mocks) and easily get started using your custom, chain-specific extensions just as easily as using the standard CosmWasm interfaces. What is left is actually wiring them up in your chain so they work as desired. Note, in order to ensure that no one tries to run the contracts on an unsupported chain, you will want to include a directive in your library, this will mean that only blockchain apps that explicitly declare their support for the extensions (please rename XYZ to your project name) will allow the contract to be uploaded, and others get error messages upon upload, not while running a critical feature later on. You just need to add a line like this at https://github.com/CosmWasm/terra-contracts/blob/master/packages/bindings/src/lib.rs#L13-L16 to your binding library to add the requirement to any contract that imports your lib. ,Calling into the SDK: Before I show how this works, I want to remind you, if you have copied , please **do not make these changes to **. We will add a new module, eg. , that will contain custom bindings between CosmWasm contracts and your native modules. There are two entry points for you to use. The first is at https://github.com/fetchai/fetchd/blob/v0.8.0-rc1/x/wasm/internal/keeper/query_plugins.go#L35, which allows you to handle your custom queries. The second is at https://github.com/fetchai/fetchd/blob/v0.8.0-rc1/x/wasm/internal/keeper/handler_plugin.go#L30 which allows you to convert the types to to be dispatched. Writing stubs for these is rather simple. You can look at the file to see this in action. In particular, here we define a at https://github.com/fetchai/fetchd/blob/v0.8.0-rc1/x/wasm/internal/keeper/reflect_test.go#L355-L385, and here we define a at https://github.com/fetchai/fetchd/blob/v0.8.0-rc1/x/wasm/internal/keeper/reflect_test.go#L303-L353. This code is responsible to take from the raw bytes serialized from your custom types in rust and parse it into Go structs. Then take these go structs and properly convert them for your custom SDK modules. You can look at the implementations for the module to see how to build these for non-trivial cases, including passing in the via a closure. Here we encode staking messages at https://github.com/fetchai/fetchd/blob/v0.8.0-rc1/x/wasm/internal/keeper/handler_plugin.go#L114-L192. Note that withdraw returns 2 messages, which is an option you can use if needed to translate into native messages. When we handle staking queries at https://github.com/fetchai/fetchd/blob/v0.8.0-rc1/x/wasm/internal/keeper/query_plugins.go#L109-L172 we take in a and dispatch the custom from the contract to the native interface, then encodes a response. When defining the return types, note that for proper parsing in the Rust contract, you should properly name the JSON fields and use the keyword if Rust expects . You must also use and pointers for all fields that correspond to a Rust , so exactly one field is serialized. ,Wiring it all together: Once you have written and tested these custom callbacks for your module, you need to enable it in your application. The first step is to write an integration test with a contract compiled with your custom SDK to ensure it works properly, then you need to configure this in . For the test cases, you must define the supported feature set at https://github.com/fetchai/fetchd/blob/ade03a1d39a9b8882e9a1ce80572d39d57bb9bc3/x/wasm/internal/keeper/reflect_test.go#L52 to include your custom name (remember above?). Then, when creating , you can pass in your custom encoder and querier at https://github.com/fetchai/fetchd/blob/ade03a1d39a9b8882e9a1ce80572d39d57bb9bc3/x/wasm/internal/keeper/reflect_test.go#L52. Run a few tests with your compiled contract, ideally exercising the majority of the interfaces to ensure that all parsing between the contract and the SDK is implemented properly. Once you have tested this and are happy with the results, you can wire it up in . Just edit the default constructor at https://github.com/fetchai/fetchd/blob/v0.8.0-rc1/app/app.go#L257-L258 to have the proper and pass in the and as the last two arguments to . Now you can compile your chain and upload your custom contracts on it."
RELEASING,RELEASING. 
RELEASING,"Creating a release. ,Determine version number: Ensure you're on master and up to date with the remote, then git describe should returns the latest tag: Here our current version is , and we want to create the release. We'll use this number in the rest of the document. ,Update version: Create the tag: ,Create release on github: Now head to the release page at https://github.com/fetchai/fetchd/releases and you must see the tag you just pushed there. Edit it and: - set the release title to the version number (here ) - Update the description from the following template. Remember to update the ecosystem versions if they did change: - Tick the box (until mainnet release) - Hit"
Security Policy,Security Policy. # Security Policy Security is very important for Fetch.ai and its community. This document outlines security procedures and general policies for the project.
Security Policy,"Reporting a Vulnerability. The team and community take all security bugs in seriously. We appreciate your efforts and responsible disclosure and will make every effort to acknowledge your contributions. Report security bugs by emailing . The lead maintainer will acknowledge your email within 48 hours, and will send a more detailed response within 48 hours indicating the next steps in handling your report. After the initial reply to your report, the security team will endeavour to keep you informed of the progress towards a fix and full announcement, and may ask for additional information or guidance. Report security bugs in third-party modules to the person or team maintaining the module."
Security Policy,"Disclosure Policy. When the security team receives a security bug report, they will assign it to a primary handler. This person will coordinate the fix and release process, involving the following steps: - Confirm the problem and determine the affected versions. - Audit code to find any potential similar problems. - Prepare fixes for all releases still under maintenance. These fixes will be released as fast as possible to PyPI."
Security Policy,Comments on this Policy. If you have suggestions on how this process could be improved please submit a pull request.
Security Policy,"Bug Bounty. We have a **bug bounty program** at https://docs.fetch.ai/bug_bounty/. Please report any security issues you find, or reach out to . Please try to be as explicit as possible, describing all the steps and example code to reproduce the security issue. Critical bug fixes will be backported to past major releases."
Security Policy,"Public Discussions. Please restrain from publicly discussing a potential security vulnerability. 🙊 It's better to discuss privately and try to find a solution first, to limit the potential impact as much as possible. --- Thanks for your help! The Fetch.ai community thank you for that. 🙇"
Documentation Setup,Documentation Setup. # Documentation Setup
Documentation Setup,Prerequisites. Make sure that you have pipenv installed on your system: pip3 install pipenv Once installed navigate to this folder in the project cd fetchd/docs Make sure all the dependencies are installed pipenv install -d
Documentation Setup,"Updating the docs. Once the dependencies are setup you must activate the environment with the following commands pipenv shell This step should update your terminal prompt and you will be able to see that the command is installed in your path which mkdocs Finally, to start the development server run the following command mkdocs serve This will listen for changes on the filesystem and automatically update the documentation."
Networks,Networks. # Networks
Networks,"Mainnet. The chain identifier of our production network is fetchhub-4. | Parameter | Value | | -------------- | ----- | | Chain ID | fetchhub-4 | | Block range | 5,300,201 --> | | Date range | 05/04/2022 --> | | Denomination | afet | | Decimals | 18 (1fet = 1000000000000000000afet) | | Version | v0.10.3 at https://github.com/fetchai/fetchd/releases/tag/v0.10.3 up to block 6295500 <br/> v0.10.4 at https://github.com/fetchai/fetchd/releases/tag/v0.10.4 up to block 7305500 <br/> v0.10.5 at https://github.com/fetchai/fetchd/releases/tag/v0.10.5 for blocks > 7305500 | | RPC Endpoint | <https://rpc-fetchhub.fetch.ai:443> | | GRPC Endpoint | <https://grpc-fetchhub.fetch.ai:443> | | REST Endpoint | <https://rest-fetchhub.fetch.ai:443> | | Block Explorer | https://explore-fetchhub.fetch.ai at https://explore-fetchhub.fetch.ai | | Token Faucet | N/A | | Genesis | | | Seed Node(s) | <!--email_off-->17693da418c15c95d629994a320e2c4f51a8069b@connect-fetchhub.fetch.ai:36456,a575c681c2861fe945f77cb3aba0357da294f1f2@connect-fetchhub.fetch.ai:36457,d7cda986c9f59ab9e05058a803c3d0300d15d8da@connect-fetchhub.fetch.ai:36458<!--/email_off--> | | Snapshots | <https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-pruned.tgz> <br /> <https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-full.tgz> <br /> <https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-archive.tgz> |"
Networks,"Test Nets. ,Dorado: This network is running the same major version of fetchd as our mainnet (), possibly at a more recent minor version. It is stable for deploying smart contracts and testing IBC. | Parameter | Value | | --------------- | ------ | | Chain ID | dorado-1 | | Denomination | atestfet | | Decimals | 18 (1testfet = 1000000000000000000atestfet) | | Min Gas Prices | 1000000000atestfet | | Version | v0.10.3 at https://github.com/fetchai/fetchd/releases/tag/v0.10.3 up to block 947800 <br/> v0.10.4 at https://github.com/fetchai/fetchd/releases/tag/v0.10.4 for blocks > 947800 and < 2198000 <br/> v0.10.5 at https://github.com/fetchai/fetchd/releases/tag/v0.10.5 for blocks > 2198000 | | RPC Endpoint | <https://rpc-dorado.fetch.ai:443> | | GRPC Endpoint | <https://grpc-dorado.fetch.ai:443> | | REST Endpoint | <https://rest-dorado.fetch.ai:443> | | Block Explorer | https://explore-dorado.fetch.ai/ at https://explore-dorado.fetch.ai/ | | Ledger Explorer | https://browse-dorado.fetch.ai/ at https://browse-dorado.fetch.ai/ | | Token Faucet | Use block explorer | | Genesis | | | Seed Node(s) | <!--email_off-->eb9b9717975b49a57e62ea93aa4480e091ae0660@connect-dorado.fetch.ai:36556,46d2f86a255ece3daf244e2ca11d5be0f16cb633@connect-dorado.fetch.ai:36557,066fc564979b1f3173615f101b62448ac7e00eb1@connect-dorado.fetch.ai:36558<!--/email_off--> | | Snapshots | <https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-pruned.tgz> <br /> <https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-full.tgz> <br /> <https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-archive.tgz> |"
CLI - Introduction,"CLI - Introduction. # CLI - Introduction The command line client provides all of the capabilities for interacting with the fetch ledger such as creating addresses, sending transactions and the governance capabilities. Before starting with the command line client you need to follow the installation instructions here at building.md"
CLI - Introduction,"Connecting to a network. ,Connecting to fetchhub mainnet : To connect to the mainnet run the following configuration steps: ,Connecting to dorado network: To connect to the dorado network run the following configuration steps: Checkout the Network Information at ../live-networks/ page for more detailed information on the available networks."
Versions,"Versions. # Versions There are multiple versions of the fetchd software with differing levels of features and maturity. The following table outlines the rough overview of these versions | Version | Maturity | Description | | ------------ | ---------- | --------------------------------------------------------------------------------------- | | v0.2.x | Deprecated | This is a stable version of the network to support agent development | | v0.3.x | Deprecated | Builds upon our stable release and adds support for the random beacon consensus module | | v0.4.x | Deprecated | Builds upon the random beacon consensus and adds support for aggregated signatures | | v0.5.x | Deprecated | Extension of v0.4.x | | v0.6.x | Deprecated | Extension of v0.5.x | | v0.7.x | Deprecated | Pre stargate fetchhub mainnet version | | v0.8.x | Deprecated | Mainline version of the network used for **Stargate** fetchhub mainnet | | v0.9.x | Deprecated | Mainline version of the network used for **Carpicorn** fetchhub mainnet | | v0.10.x | Stable | Mainline version of the network used for **Dorado** fetchhub mainnet | # Upgrade history For node operators, the full upgrade history, documentations and procedures are available at: https://github.com/fetchai/genesis-fetchhub at https://github.com/fetchai/genesis-fetchhub"
Mainnet is here,"Mainnet is here. # Mainnet is here The fetchhub mainnet forms the core of the Fetch.ai ecosystem. In these pages, you will find all information to setup your client and connect on the network at ./live-networks/ and cli-introduction at ./cli-introduction/ pages. This documentation covers some of the things you need to know in order to prepare for and develop on this network."
Mainnet is here,"Test Networks. The starting point for most will be our test network at https://docs.fetch.ai/ledger_v2/live-networks/#test-nets, since it can provide you with test tokens with no value, that you can safely experiment with. Head over the Command line client at https://docs.fetch.ai/ledger_v2/cli-introduction/ section for guidance on how to install and configure the client."
State-sync,"State-sync. # State-sync State sync is a feature which allows you to quickly bootstrap a new node by allowing it to pull a *state snapshot* taken by other nodes. The state sync feature is only available from and later. Prior versions needed to either sync from scratch or restore a chain snapshot at ../snapshots, which both could take hours before having the node fully synced. With state sync, it now takes only a few minutes before having an operational node."
State-sync,"Configuring the new node. In order to instruct the node to sync itself using a state sync snapshot, it need some configuration in the file. Open this file in an editor and lookup for the section. By default, it should looks like this: A few changes are needed: - First, set to activate the state sync engine. - Then, **at least 2** rpc servers must be provided. A good place to find some is the cosmos chain registry at https://github.com/cosmos/chain-registry/blob/master/fetchhub/chain.json#L62. Servers must be comma separated without space (ie: ). These servers will be used to verify the snapshots, so make sure you trust them enough for this. - a *recent* and are needed. Recent means it must be contained in the (168 hours, or ~1 week old by default). These can be obtained from a RPC server **you trust to provide you correct data** (and the 2nd RPC server from will be charged of confirming that the data are correct). - And last, set to (the default value seems too short and can lead to ""context deadline exceeded"" timeout errors when verifying the hashes) To retrieve the correct value for a fetch.ai RPC server, and the current network height, use: and set the trusted_hash and trusted_height values in the config file. Once this is set, make sure you have the correct genesis by downloading it from the RPC node: and start the node using the seeds from the chain-registry: <!--email_off--> <!--/email_off--> After the node initialized, it will start searching for available snapshots, and it should print log messages similar to: The node will select the one with the value the closest to the tip of the chain, and it will then start restoring the state, and finish syncing the few blocks remaining. If it fails to verify any blocks or hash when restoring, it will attempt to restore the next available snapshot, and, if no more are available, will fallback in discovery mode until an usable snapshot is available."
State-sync,"Configure an existing node to provide snapshots. In order to provide new nodes snapshots they can start from, existing nodes need to be configured to create these snapshots. This requires changes in the file, in the section. Here must be set to a number of blocks between each snapshot creation and it must be a multiple of your node prunning settings (default is 100, so valid values are 100, 1000, 700...). The number of snapshots to keep can be set with ."
Building the Ledger,Building the Ledger. # Building the Ledger
Building the Ledger,"Prerequisites. - Go 1.18+ (installation instructions available here at https://golang.org/dl/) - Packages: , (on Ubuntu, install them with )"
Building the Ledger,"Building the code. Download the latest released version from github and build the project using the following commands: Then build the code with the command: This will generate the binary. For non-developer users we recommend that the user installs the binaries into their system. This can be done with the following command: This will install the binaries in the directory specified by your environment variable (default to ). This should return a path such as (might be different depending on your actual go installation). > If you get no output, or an error such as , possible cause can either be that failed with some errors or that your go binary folder (default: ~/go/bin) is not in your . > > To add the ~/go/bin folder to your PATH, add this line at the end of your ~/.bashrc: > > >and reload it with: > > You can also verify that you are running the correct version This should print a version number that must be compatible with the network you're connecting to (see the network page at ../live-networks/ for the list of supported versions per network)."
Building the Ledger,"FAQ. - **Error: failed to parse log level (main:info,state:info,:error): Unknown Level String: 'main:info,state:info,:error', defaulting to NoLevel** This means you had a pre-stargate version of fetchd (<= v0.7.x), and just installed a stargate version (>= v0.8.x), you'll need to remove the previous configuration files with:"
