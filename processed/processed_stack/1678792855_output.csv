title,text
deploy-a-contract,"deploy-a-contract. You can deploy smart contracts in CosmPy using . For this, you will need the path to where the contract is stored (in this case ), a at connect-to-network.md and a at wallets-and-keys.md: You can now start interacting with the contract. To get the address of where the contract is deployed on the network: You can query the values of the contract's state variables: You can also set these values. The following sets the state variable to : Let's check if this was set correctly: Similarly, you can clear the state variables:"
liquidity-pool,liquidity-pool. 
liquidity-pool,"Swap Tokens. You can interact with a liquidity pool by swapping atestfet for CW20 tokens or vice versa. First, perform all the necessary imports: Set the network configuration, define a local wallet and add some tokens to it using the FaucetApi Define the CW20, pair, and liquidity token contracts with the following addresses: Swap the defined of atestfet for CW20 tokens You can query your CW20 balance using the following code: To trade 10 CW20 tokens for atestfet you can use the following:"
liquidity-pool,"Add and Remove Liquidity . You need to increase your wallet's allowance to provide CW20 tokens to the liquidity pool. You don't need to increase the allowance to provide atestfet To set the amount of atestfet to be added to the liquidity pool and not influence the existing token prices, we need to choose an amount that matches the atestfet:CW20 token ratio already existing in the pool. For this reason, we will query the pool to observe the atestfet:CW20 token ratio At the moment the code was run, the ratio was close to 247:10 atestfet:CW20, and since we defined above the amount of CW20 tokens to provide to the liquidity pool as 100, we will match the LP pool ratio by setting the atestfet amount as 2470. It will be difficult to exactly match the current ratio of the pool, but when adding liquidity to the pool, there is a slippage_tolerance parameter that allows a certain percentage change in the price. When providing liquidity, you are rewarded with newly minted LP tokens. LP tokens represent the liquidity provider's share in the pool. You can burn your LP tokens to withdraw your share from the liquidity pool, for more information visit at https://docs.terraswap.io/. The following code shows how to withdraw your share from the LP. You can now query you LP token balance to observe that it has gone down to zero You can also check the full code example at at https://github.com/fetchai/cosmpy/blob/develop/examples/aerial_liquidity_pool.py"
connect-to-network,"connect-to-network. To start interacting with a blockchain, you first need to establish a connection to a network node. You can use as a client object which takes a as an argument. For convenience, some networks' configurations are provided automatically. For example, is the configuration for the Fetch ledger. If you want to interact with other chains, you can customise as shown in the example below: A full list of chain identifiers, denominations and end-points can be found at the Cosmos chain registry at https://github.com/cosmos/chain-registry/."
swap-automation,"swap-automation. A mean-reversion strategy expects the prices to return to “normal” levels or a certain moving average following a temporary price spike. We can construct a similar strategy using the Liquidity Pool, where we will set upper and lower bound prices that will trigger a sell and a buy transaction respectively. If the behavior of the LP prices works as expected always returning to a certain moving average, we could profit by selling high and buying low. We will do this by swapping atestfet and CW20 with the Liquidity Pool, we refer to a sell transaction when we sell atestfet and get CW20 tokens, a buy transaction would be exactly the opposite. The code will require the following imports: We will define the *swap_native_for_cw20* function that trades of atestfet from for CW20 tokens by executing a : Now, we will define the *swap_cw20_for_native* function that does exactly the opposite of the function defined above: trades of CW20 tokens from for atestfet. This time the CW20 is executed using the . Finally, you need to include the {""swap"":{}} message in the ""msg"" field. However, this swap message has to be encoded into base64. When you encode {""swap"":{}} message into base64 you get: eyJzd2FwIjp7fX0= Set the network configuration, define a local wallet and add some tokens to it using the FaucetApi Define the CW20, pair, and liquidity token contracts with the following addresses: We will define a trading wallet named that will keep track of the amount of atestfet or CW20 tokens we hold at each moment. The variable will keep track of the token type. We will never have a mixed trading wallet since in this strategy, every time we perform a swap, we sell all the current tokens. Now we will define the upper and lower price bounds (atestfet/CW20) that will trigger a buy and a sell transaction of atestfet. We also define the commission rate (0.3% in at https://docs.terraswap.io/docs/introduction/trading_fees/) and the time step to query the pool's price. Finally, we will initialize a loop, in every step it will: * Query the Liquidity Pool status * Check if current trading wallet's * Calculate the *atestfet/CW20* price using the tokens received if the whole trading wallet's balance was to be swapped with the liquidity pool * If atestfet sell/buy price is equal or lower/higher than the lower/upper bound, it will trigger a sell/buy transaction of atestfet to buy/sell CW20 tokens. * Update trading wallet balance and * Sleep and repeat This code assumes other traders performing transactions with the Liquidity Pool that will generate price movements. You can check out the full example at at https://github.com/fetchai/cosmpy/blob/develop/examples/aerial_swap_automation.py"
wallets-and-keys,"wallets-and-keys. To make changes on a network, you will need to start sending transactions to it. This in tern involves managing private keys and addresses. Luckily, CosmPy makes this relatively straightforward. The following code outlines how to both generate a completely new private key and how to recover a previously generated one: The object is one of CosmPy's low level primitives. This is why it is generally paired with a object in most scenarios. Below, a (a kind of ) is created using the private key: Creating the wallet allows users to query useful information such as the address from the wallet directly."
wallets-and-keys,"Existing account. ,From mnemonic: If you have the mnemonic phrase to an account, you can get the associated private key as follows: !!! danger Of course in real applications, you should **never** include a mnemonic in public code. ,Custom prefix network:: In case you are using a network other than fetch.ai's, you can provide the custom prefix when creating the wallet:"
query-balance,query-balance. A at connect-to-network.md object can be used to query the balances associated with a particular address: This will return a of objects that contain and variables that correspond to all the funds held at the address and their denominations. This list includes all natively defined coins along with any tokens transferred using the inter-blockchain communication (IBC at https://ibcprotocol.org/) protocol. It's also possible to query the funds associated with a particular denomination by calling which will return the value of the (integer) funds held by the address with the specified denomination. If the argument is omitted the function will return the fee denomination specified in the object used to initialise the .
auto-compounder,"auto-compounder. When an account delegates tokens to a network's validator, it will start generating rewards proportional to the amount of at staking.md delegated. But since rewards aren't automatically added to your stake and therefore don't contribute to future rewards, we can perform a compounding strategy to generate exponential rewards."
auto-compounder,Delegate. The first thing we need to do is delegate some tokens to a . You can do so by using a at wallets-and-keys.md and specifying the validator address and amount.
auto-compounder,"Auto Compounder. Then we can construct a code that claims rewards and delegates the rewarded tokens back to the . This way we keep growing our at staking.md and therefore we generate compounded rewards. We first need to define the and the compounding . It is important to note that each time an account performs a claim or a delegate transaction it has to pay certain fees, therefore the compounding period has to be long enough to generate sufficient rewards to exceed the fees that will be paid in each transaction. Finally, we start a timer that claims rewards and delegates them in each time period. Notice that in the code below we constructed a while loop that will be running until the timer exceeds the . Each loop will last the time specified in . We query the balance before and after claiming rewards to get the value of the reward after any fees. If the true reward value is positive, we delegate those tokens to the validator, if it is negative, it means that the fees from claiming and delegating transactions exceeded the rewards, and therefore we won't delegate. You can view the full python example at staking auto-compounder at https://github.com/fetchai/cosmpy/blob/develop/examples/aerial_compounder.py"
low-level-api,"low-level-api. The Cosmpy library provides a high-level API which greatly simplifies the most common use cases when interacting with Cosmos-based chains (e.g. sending tokens at send-tokens.md, staking at staking.md, deploying and interacting with contracts at deploy-a-contract.md). There are documentation at connect-to-network.md and example code at https://github.com/fetchai/cosmpy/tree/master/examples covering such use cases. However, cosmpy also provides low-level access to the entire Cosmos-SDK, enabling the full gamut of functionality to be accessed, albeit with a little more boilerplate. Here, we aim to help developers navigate the low-level, protobuf-based API functionality, provided by Cosmpy."
low-level-api,"Recap: High Level API - Aerial. As a reminder, here is a quick example of using the high level functionality provided by Cosmpy. In this case, we connect to a testnet, create a wallet, stake some tokens with a validator, then claim our rewards: The available high-level helper functions provided by cosmpy can be found by browsing for instance the aerial client package at https://github.com/fetchai/cosmpy/blob/master/cosmpy/aerial/client/__init__.py."
low-level-api,"Low Level API. ,Simple Messages: Not all Cosmos-SDK functionality is encapsulated in the high level aerial packages. In which case, it is necessary to locate and use the definition of the relevant protobuf message. Analogous to the rewards claim example above, what if a validator operator wanted to claim their commission? At the time of writing, there is no high-level API to achieve this, so the low level API must be used. In the protos at https://github.com/fetchai/cosmpy/tree/master/cosmpy/protos directory, there is a MsgWithdrawValidatorCommission at https://github.com/fetchai/cosmpy/blob/6d7b5f49722b67c803145d55aa291fe426c19994/cosmpy/protos/cosmos/distribution/v1beta1/tx_pb2.py#L160 message, which is what we need. It takes a single parameter which is a string. To send a transaction containing such a message: ,Nested messages: The above example creates and broadcasts a simple message. However, sometimes it is necessary to include one message in another. For example, what if we wanted to use the above message but execute it from a different account using (i.e. use an account which holds minimal funds, whose keys need not be treated with the same level of care as those of the validator itself)? In this case, we'll need to send an MsgExec at https://github.com/fetchai/cosmpy/blob/4abb976753edcab402fcc23d4dce3ab67b73b608/cosmpy/protos/cosmos/authz/v1beta1/tx_pb2.py#L114 message, which can be found in tx_pb2.py at https://github.com/fetchai/cosmpy/blob/4abb976753edcab402fcc23d4dce3ab67b73b608/cosmpy/protos/cosmos/authz/v1beta1/tx_pb2.py under area of . This message takes two parameters. The is a simple string address similar to the above. But the field needs to support multiple types of messages and not just . Protobuf is strongly typed, so to facilitate this flexibility, it is necessary to first pack the nested message into a message. Therefore, we arrive at the code looking like: ,More protobuf examples: Before running the above, the necessary grant must first be put in place. For Ledger Nano users (other hardware wallets are also available) that might mean an excursion to the command line. For the Fetchai network using FetchD at https://docs.fetch.ai/ledger_v2/: By default, the above provides one year's worth of authorization to withdraw validator commission using accounts already present in the keyring. For those with access to their keys in python:"
send-tokens,"send-tokens. Once you have your at wallets-and-keys.md configured, you can send transactions to the network. The object provides useful utilities to do common operations. The following example shows how to send to another address:"
wallet-topup,"wallet-topup. In a case where you are performing multiple transactions from a certain task_wallet, you can set an algorithm to keep that wallet address topped-up. For this use case, we will use three different wallets: wallet, authz_wallet, and task_wallet. Wallet will be the main wallet address that we don't want to give full access to, therefore we will authorize authz_wallet to send a certain amount of tokens from wallet to task_wallet every time task_wallet balance falls below a certain threshold. This way, task_wallet can keep performing transactions using the main wallet's tokens by being topped-up by authz_wallet. Start by defining wallet, authz_wallet and task_wallet address. Wallet will need to have enough tokens available to top-up task_wallet, and authz_wallet will need enough tokens to pay for transaction fees. Now you will need to give authorization to authz_wallet to send tokens from wallet. You will define the expiration and the spend limit of the authorization in and . The code below shows how to perform this kind of transaction: Next, you will need to define the amount to top-up, the threshold that will trigger the top-up, and the interval time to query the task_wallet balance. We will define these amounts in the following variables: , and . Finally, run a continuously running loop that will: * Check the main wallet's balance to make sure it has enough tokens to top up the task_wallet_address * Check task_wallet's balance, if it is lower than then authz_wallet will send of tokens from wallet to task_wallet * Sleep and repeat While the code above keeps running, you can make sure that task_wallet is always topped-up as long as authz_wallet has authorization to send the required tokens and the main wallet has enough balance. You can also check out the authorization and top-up code examples at at https://github.com/fetchai/cosmpy/blob/develop/examples/aerial_authz.py and at https://github.com/fetchai/cosmpy/blob/develop/examples/aerial_topup.py respectively."
