title,text
Message Routing,"Message Routing. # Message Routing Message routing can be split up into the routing of incoming and outgoing . It is important to keep in mind that <a href=""../interaction-protocol"">interaction protocols</a> can be maintained between agents (agent to agent) and between components of the AEA (component to component). In the former case, the / fields of the are agent addresses which must follow the address standard of agents, in the latter case they are component public ids. Crucially, both addresses must reference the same type: agent or component."
Message Routing,"Incoming . - receive or create which they deposit in the - for agent-to-agent communication only, the keeps track of the via which the was received. - the picks off the - the tries to decode the message; errors are handled by the - are dispatched based on two rules: 1. checks if field can be interpreted as , if so uses that together with the to dispatch to the protocol's in the specified , else 2. uses the to dispatch to the protocol's in all skills supporting the protocol. !!! note For agent-to-agent communication it is advisable to have a single skill implement a given protocol. Skills can then forward the messages via skill-to-skill communication to other skills where required. Otherwise, received agent-to-agent messages will be forwarded to all skills implementing a handler for the specified protocol and the developer needs to take care to handle them appropriately (e.g. avoid multiple replies to a single message)."
Message Routing,"Outgoing . - deposit in - constructs an from the - assigns messages to relevant based on the following rules: 1. Component to component messages are routed by their 2. Agent to agent messages are routed following four rules: 1. checks if exists and specifies a , if so uses that else 2. checks which connection handled the last message from , if present uses that else 3. checks if default routing is specified for the referenced in the , if so uses that else 4. sends to default . - can process directly or encode them for transport to another agent."
Message Routing,Usage of the . The is used to maintain agent-to-agent communication only and is managed almost entirely by the framework. The developer can set the explicitly for the first message in a dialogue to achieve targeted routing to connections (see 2. for outgoing messages). This is relevant when the same agent can be reached via multiple connections. The is not sent to another agent.
Architectural Diagram,"Architectural Diagram. # Architectural Diagram The framework has two distinctive parts. - A **core** that is developed by the Fetch.ai team as well as external contributors. - **Extensions** (also known as **packages**) developed by any developer. Currently, the framework supports four types of packages which can be added to the core as modules: - <a href=""../skill"">Skills</a> encapsulate logic that deliver economic value to the AEA. Skills are the main focus of the framework's extensibility. - <a href=""../protocol"">Protocols</a> define the structure of agent-to-agent and component-to-component interactions (messages and dialogues) for agents. - <a href=""../connection"">Connections</a> provide interfaces for the agent to connect with the outside world. They wrap SDKs or APIs and provide interfaces to networks, ledgers and other services. - <a href=""../contract"">Contracts</a> wrap smart contracts for Fetch.ai and third-party decentralized ledgers. The following figure illustrates the framework's architecture: <img src=""../assets/simplified-aea.jpg"" alt=""Simplified illustration of an AEA"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:100%;""> The execution is broken down in more detail below: <img src=""../assets/execution.jpg"" alt=""Execution of an AEA"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:100%;""> The agent operation breaks down into three parts: - **Setup**: calls the method of all registered resources - **Operation**: - Agent loop (Thread 1 - Asynchronous agent loop): - : this function grabs all Envelopes waiting in the queue and calls the method on the Handler(s) responsible for them. - : this function calls the method of all registered Behaviours. - : this function enqueues scheduled tasks for execution with the and executes the decision maker. - Task loop (Thread 2- Synchronous): executes available tasks - Decision maker loop (Thread 3- Synchronous): processes internal messages - Multiplexer (Thread 4 - Asynchronous event loop): processes incoming and outgoing messages across several connections asynchronously. - **Teardown**: calls the method of all registered resources To prevent a developer from blocking the main loop with custom skill code, an execution time limit is applied to every and call. By default, the execution limit is set to seconds, which disables the feature. You can set the limit to a strictly positive value (e.g. seconds) to test your AEA for production readiness. If the or time exceed this limit, the call will be terminated. An appropriate message is added to the logs in the case of some code execution being terminated."
Use Multiplexer Stand-Alone,"Use Multiplexer Stand-Alone. # Use Multiplexer Stand-Alone The can be used stand-alone. This way a developer can utilise the protocols and connections independent of the or classes. First, import the Python and application specific libraries and set the static variables. (Get the directory from the AEA repository .)"
Use Multiplexer Stand-Alone,Instantiate a . A only needs a list of connections. The is a simple connection which reads from and writes to file.
Use Multiplexer Stand-Alone,"Start the . We can run a multiplexer by calling, which starts the 'receive' and 'send' loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages."
Use Multiplexer Stand-Alone,Send and Receive an Envelope. We use the input and output text files to send an envelope to our agent and receive a response
Use Multiplexer Stand-Alone,"Shutdown. Finally, stop our multiplexer and wait for it to finish"
Use Multiplexer Stand-Alone,Your Turn. Now it is your turn to develop a simple use case which utilises the to send and receive Envelopes.
Use Multiplexer Stand-Alone,"Entire Code Listing. If you just want to copy and paste the entire script in you can find it here: ??? note ""Click here to see full listing:"""
ORM Integration,ORM Integration. # ORM Integration This guide demonstrates how to configure an AEA to interact with a database using objects.
ORM Integration,"Discussion. Object-relational-mapping (ORM) is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of this guide is to demonstrate how you can create an easily configurable AEA that reads data from a database using ORMs. - We assume, that you followed the guide for the <a href=""../thermometer-skills/""> thermometer-skills. </a> - We assume, that we have a database with table name . This table contains the following columns and . - We assume, that we have a hardware thermometer sensor that adds the readings in the database (although you can follow the guide without having access to a sensor). Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The command will install each dependency that the specific AEA needs and which is listed in the skill's YAML file."
ORM Integration,Communication. This diagram shows the communication between the various entities in the case where the thermometer data is successfully sold by the seller AEA to the buyer.
ORM Integration,"Preparation Instructions. ,Dependencies: Follow the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start."
ORM Integration,"Demo Instructions. ,Create the Seller AEA: First, fetch the seller AEA which provides thermometer data: ??? note ""Alternatively, create from scratch:"" The following steps create the seller from scratch: ,Create the Buyer Client: In another terminal, fetch the buyer AEA: ??? note ""Alternatively, create from scratch:"" The following steps create the car data client from scratch: ,Add Keys for the Seller AEA: First, create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: ,Add Keys and Generate Wealth for the Buyer AEA: The buyer needs to have some wealth to purchase the thermometer data. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Then, create some wealth for the buyer based on the network you want to transact with. On the Fetch.ai network: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: ,Update the Seller and Buyer AEA Skill Configurations: In , replace the with your data: The is used to register the service in the <a href=""../simple-oef"">SOEF search node</a> and make your agent discoverable. In ) ensure you have matching data. After changing the skill configuration files you should run the following command for both agents to install each dependency: ,Modify the Seller's Strategy: Before being able to modify a package we need to eject it from vendor: This will move the package to your directory and reset the version to and the author to your author handle. Open (in ) and make the following modifications: Import the newly installed library in your strategy. Then modify your strategy's function to match the following code: At the end of the file modify the function: Also, create two new functions, one that creates a connection with the database, and another that populates the database with some fake data. This is needed in the case you do not have access to an actual thermometer sensor that inserts data in the database. After modifying the skill we need to fingerprint it: ,Run Both AEAs: First, run the thermometer (seller) AEA: Once you see a message of the form take note of this address. (Alternatively, use to retrieve the address.) This is the entry peer address for the local <a href=""../acn"">agent communication network</a> created by the thermometer AEA. Then, configure the thermometer client (buyer) to connect to this same local ACN by running the following command in the buyer terminal, replacing with the value you noted above: Then run the thermometer client AEA: You will see that the AEAs negotiate and then transact using the configured testnet."
ORM Integration,"Delete the AEAs. When you're done, stop the agents (), go up a level and delete the AEAs."
Agent-Oriented Development,"Agent-Oriented Development. # Agent-Oriented Development In this section, we discuss some of the most fundamental characteristics of an agent-oriented approach to solution development, which might be different from existing paradigms and methodologies that you may be used to. We hope that with this, we can guide you towards the right mindset when designing your own agent-based solutions to real world problems."
Agent-Oriented Development,"Decentralisation. on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences which may not necessarily be aligned with one another or the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to **a.** the diversity of ownership and control over a system's constituents, and **b.** the absence of central authorities between them. **Example:** To better illustrate the distinction between centralized and decentralized systems, consider another example: search and discoverability in a commerce environment. In a centralized system (say Amazon), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search-related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However, in a decentralized system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for."
Agent-Oriented Development,"Conflicting Environment. As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralized system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worse yet contradictory, with those of others. As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory. **In practice:** There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be: - Incomplete: what is unrevealed may have been deemed private for strategic reasons. - Uncertain: it may be the result of an inaccurate prediction. - Incorrect: it could be an outright lie, due to the adversarial nature of the environment. Therefore, one can argue that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise."
Agent-Oriented Development,"Asynchronization. in MAS:** In the context of multi-agent systems, the decentralized and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent sends a message requesting some resources from an agent . Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: may never receive 's request, or may receive it after a long delay. Furthermore, could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, may _decide_ to reply much later, to the point that the resource is no longer useful to agent , or may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because assigns a low priority to answering over its other tasks. But that's beside the point. The takeaway is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system. **Objects vs agents:** In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object’s method is public, the object has no control over whether that method is executed. We cannot take for granted that an agent will execute an action (the equivalent of a method in object-oriented systems) just because another agent wants it to; this action may not be in the best interests of agent . So we do not think of agents as invoking methods on one another, rather as _requesting_ actions. If requests to perform an action, then may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from <a href=""https://www.wiley.com/en-gb/An+Introduction+to+MultiAgent+Systems%2C+2nd+Edition-p-9781119959519"" target=""_blank"">An Introduction to MultiAgent Systems</a> by <a href=""https://www.cs.ox.ac.uk/people/michael.wooldridge/"" target=""_blank"">Michael Wooldridge</a>): >objects do it for free; agents do it because they want to. All of this makes asynchronization the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision-making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks."
Agent-Oriented Development,"Time. Closely related with the discussion of asynchronicity, is the idea that in multi-agent systems, time is not a universally agreed notion. Agents may not necessarily share the same clock and this fact must be taken into account when designing agent-based systems. For example, you cannot necessarily expect agents to synchronise their behaviour according to time (e.g. perform a certain task at a time ). Another related issue, is that unlike some agent-based simulation (ABS) systems where there is a global tick rate for all agents, in AEA-based systems tick rates may be different for different agents. This is due to the fundamental difference that ABS systems control some aspects of all of their agents' executions while in AEA-based systems, agents are truly decoupled from one another - most likely distributed and running on different machines and networks - and there is absolutely no central unit that moderates any aspect of their behaviour."
Agent-Oriented Development,"Complex, Incomplete, Inconsistent and Uncertain. The fourth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driver-less vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge ""it is safe to cross the road because the light is green"", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment."
Agent-Oriented Development,"Further Reading. - Wooldridge, M. (2009). _An Introduction to MultiAgent Systems_. Wiley, Second edition. - Shoham, Y. and Leyton-Brown, K. (2008). _Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations_. Cambridge University Press"
Agent Communication Network,"Agent Communication Network. # Agent Communication Network The agent communication network (ACN) provides a system for agents to find each other and communicate, solely based on their wallet addresses. It addresses the message delivery problem."
Agent Communication Network,"Message Delivery Problem. Agents need to contact each others. Given the wallet address of a target agent, how can the originator agent deliver a message to it whilst guaranteeing certain properties? The properties we would like to have, are: - Reliability: with guarantees on message reception - Authentication: to prevent impersonation - Confidentiality: to prevent exposing sensitive information within the message - Availability: some guarantees about the liveness of the service (tampering detection) The problem statement and the agent framework context impose a number of design constraints: - Distributed environment: no assumption are placed about the location of the agent, they can be anywhere in the publicly reachable internet - Decentralized environment: no trusted central authority - Support for resource-constrained devices The ACN solves the above problem whilst providing the above guarantees and satisfying the constraints."
Agent Communication Network,"Peers. are not to be equated with agents. They are processes (usually distributed and decentralized) that together maintain the service. To use the service, agents need to associate themselves with peers. Thanks to digital signatures, the association between a given peer and agent can be verified by any participant in the system."
Agent Communication Network,"Distributed Hash Table. At its core, the ACN implements a distributed hash table (DHT). A DHT is similar to a regular hash table in that it stores key-value pairs. However, storage is distributed across the participating machines (peers) with an efficient lookup operation. This is enabled by: - Consistent hashing: decide responsibility for assignment of the DHT key-value storage - Structured overlays: organize the participating peers in a well-defined topology for efficient routing <img src=""../assets/dht.jpg"" alt=""DHT"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:50%;""> For the ACN, we use the DHT to store and maintain association between an agent address and the (network) location of its peer."
Agent Communication Network,"N-Tier Architecture. To satisfy different resource constraints and flexible deployment the ACN is implemented as a multi-tier architecture. As such, it provides an extension of the client-server model. The agent framework exploits this by implementing different tiers as different <a href=""../api/connections/base#connection-objects""></a>: <img src=""../assets/acn-tiers.jpg"" alt=""DHT"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:80%;""> !!! note The connection is not available yet."
Agent Communication Network,"Trust and Security. An agent can choose which connection to use depending on the resource and trust requirements: - connection: the agent maintains a peer of the ACN. The agent has full control over the peer and does not need to trust any other entity. - connection: the agent maintains a client connection to a server which is operated by a peer of the ACN. The agent does need to trust the entity operating the peer. All communication protocols use public cryptography to ensure security (authentication, confidentiality, and availability) using TLS handshakes with pre-shared public keys. <img src=""../assets/acn-trust-security.jpg"" alt=""DHT"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:80%;"">"
Simple-OEF: Agent Search and Discovery,"Simple-OEF: Agent Search and Discovery. # Simple-OEF: Agent Search and Discovery The full documentation is available <a href=""https://docs.fetch.ai/soef/simple-oef/"" target=""_blank"">here</a>."
How AEAs Talk to Each Other - Interaction Protocols,"How AEAs Talk to Each Other - Interaction Protocols. # How AEAs Talk to Each Other - Interaction Protocols Although one can imagine scenarios where single AEAs pursue their goals in isolation without interacting with other AEAs, there is no doubt that by working together, AEAs have the potential of achieving much more, especially when taking into account agents' heterogeneity, specialisations, and differing and often complimentary local views of the environment. Interactions in the AEA world are in the form of communication. This is influenced by established practices in the field of multi-agent systems and the prominent speech-act theory which suggests that a communicative expression is not only about transferring information from the speaker to the hearer, but that there may be meanings and commitments beyond the statement's appearance. Therefore, speech may more suitably be considered as action. For example, ""I hereby appoint you as chairman"" is not just a sequence of words, but an action done by the speaker with wide-ranging consequences for the hearer and any other audience to that sentence. <a href=""https://en.wikipedia.org/wiki/Interaction_protocol"" target=""_blank"">Interaction protocols</a> are thus possible communication scenarios between agents or agent components (specifically, skills and connections). There are multiple types of interactions an AEA can have: - AEA-to-AEA interactions. You can find some examples in the <a href=""../demos"">demo section</a>. - Interactions between an AEA's internal components. <img src=""../assets/interaction-protocols.jpg"" alt=""Interaction protocols"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:80%;""> Usually, an interaction involves three types of framework packages: <a href=""../skill"">skills</a>, <a href=""../protocol"">protocols</a> and <a href=""../connection"">connections</a>."
How AEAs Talk to Each Other - Interaction Protocols,"Examples. ,Example 1: Negotiation: The <a href=""../generic-skills"">generic buyer/seller skills</a> use the protocol which defines the negotiation dialogue between two AEAs. The and skills implement specific strategies for engaging in such negotiations, by providing the logic for producing negotiation messages to be sent, handling negotiation messages received. The connection is then used for connecting to the <a href=""../acn"">agent communication network</a> enabling two AEAs with these skills to deliver negotiation messages to each other. ,Example 2: AEA <> Web Client: In the <a href=""../http-connection-and-skill"">http connection guide</a> we demonstrate how an AEA with a http server connection (e.g. ) receives http payloads from web clients, translates them to messages conforming with the protocol and passes it to a skill (e.g. ) to process. The protocol in this case is used for communication between the connection and the skill. ,Example 3 : AEA <> 3rd Party Server: The connection can be used to make requests to third party servers. In this case, a skill containing the logic for the production of http requests would create messages conforming with the protocol and sends it to the connection which in turn translates it into http payload and sends it to the destination server. Note that in general, third party SDKs can be wrapped in a connection and shared with other developers as a package. Often this also involves creating a custom protocol to enforce the type of interactions permitted between skills and the connection wrapping the SDK."
How AEAs Talk to Each Other - Interaction Protocols,"Next Steps. ,Recommended: We recommend you continue with the next step in the 'Getting Started' series: - <a href=""../generic-skills-step-by-step/"">Trade between two AEAs</a> ,Relevant Deep-Dives: Most AEA development focuses on developing the and necessary for an AEA to deliver against its economic objectives and implement interaction protocols. Understanding is core to developing your own agent. You can learn more about the agents use to communicate with each other and how they are created in the following section: - <a href=""../protocol"">Protocols</a> Most of an AEA developer's time is spent on development. are the core business logic components of an AEA. Check out the following guide to learn more: - <a href=""../skill"">Skills</a> In most cases, one of the available packages can be used. Occasionally, you might develop your own : - <a href=""../connection"">Connections</a>"
Profiling,Profiling. # Profiling
Profiling,"Measuring Runtime Cost. It is important to emphasise the fact that the AEA is a framework, so ultimately its running cost will highly depend on the number and type of components which are being run as part of a given AEA. The other cost factor is determined by the cost of running the core framework itself and how fast and efficient the framework is in interconnecting the components. These observations can provide guidance on what to report as part of the cost of running an AEA. Here is a list of suggestion on how to measure the cost of running an AEA: - the cost of running the framework itself: by running a minimal agent with an idle loop (the default one) with no connections, skills or protocols and measuring memory usage and CPU consumption as a baseline. - the cost of interconnecting components: by running an agent with a basic skill (e.g. ) and measuring memory usage and CPU consumption relative to number of messages exchanged as well as bandwidth. - the cost of basic components: dialogues memory relative to number of messages, SOEF connection baseline memory usage, P2P connection baseline memory usage, smart contract baseline memory usage The command can be used to report measures in all of the above scenarios."
Demos,"Demos. # Demos We provide demo guides for multiple use-cases, each one involving several AEAs interacting in a different scenario. These demos serve to highlight the concept of AEAs as well as provide inspiration for developers. Demos should not be taken as production ready software, although every care is taken to fix bugs when reported. Demos are alphabetically sorted, we recommend you start with the <a href=""../weather-skills"">weather skills demo</a>."
