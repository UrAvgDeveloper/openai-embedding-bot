title,text
Core Components - Part 1,"Core Components - Part 1. # Core Components - Part 1 The AEA framework consists of several core components, some required to run an AEA and others optional. The following sections discuss the inner workings of the AEA framework and how it calls the code in custom packages (see <a href=""https://en.wikipedia.org/wiki/Inversion_of_control"" target=""_blank"">inversion of control</a> and a helpful comparison <a href=""https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/"" target=""_blank"">here</a>). Whilst it is in principle possible to use parts of the framework as a library, we do not recommend it."
Core Components - Part 1,"The Elements Each AEA Uses. ,Envelope:,Protocol: specific , wrapped in , are sent and received to other agents, agent components and services via . ,Connection: A <a href=""../api/connections/base#connection-objects""></a> wraps an SDK or API and provides an interface to networks, ledgers or other services. Where necessary, a is responsible for translating between the framework specific with its contained and the external service or third-party protocol (e.g. ). The framework provides one default , called (current version ). It implements an I/O reader and writer to send to the agent from a local file. Additional can be added as packages. For more details on read the <a href=""../connection""> guide </a>. An AEA runs and manages via a . ,Multiplexer: of an AEA"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:50%;""> The <a href=""../api/multiplexer#multiplexer-objects""></a> is responsible for maintaining (potentially multiple) . It maintains an <a href=""../api/multiplexer#inbox-objects""></a> and <a href=""../api/multiplexer#outbox-objects""></a>, which are, respectively, queues for incoming and outgoing from the perspective of . ,Skill:s of an AEA"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:50%;""> <a href=""../api/skills/base#skill-objects""></a> are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A encapsulates implementations of the three abstract base classes , , , and is closely related with the abstract base class : - <a href=""../api/skills/base#handler-objects""></a>: each has zero, one or more objects. There is a one-to-one correspondence between and the protocols in an AEA (also known as the _registered protocols_). Handlers implement AEAs' **reactive** behaviour. If an AEA understands a referenced in a received (i.e. the protocol is registered in this AEA), this envelope is sent to the corresponding which executes the AEA's reaction to this . - <a href=""../api/skills/base#behaviour-objects""></a>: a can have zero, one or more , each encapsulating actions which further the AEAs goal and are initiated by internals of the AEA rather than external events. Behaviours implement AEAs' **pro-activeness**. The framework provides a number of <a href=""../api/skills/behaviours"">abstract base classes</a> implementing different types of simple and composite behaviours (e.g. cyclic, one-shot, finite-state-machine, etc), and these define how often and in what order a behaviour and its sub-behaviours must be executed. - <a href=""../api/skills/base#model-objects""></a>: zero, one or more that inherit from the abstract base class and are accessible via the . - <a href=""../api/skills/tasks#task-objects""></a>: zero, one or more encapsulate background work internal to the AEA. differs from the other three in that it is not a part of , but are declared in or from if a packaging approach for AEA creation is used. A can read (parts of) an AEA's state (as summarised in the <a href=""../api/context/base#agentcontext-objects""></a>), and propose actions to the AEA according to its specific logic. As such, more than one could exist per , competing with each other in suggesting to the AEA the best course of actions to take. In technical terms, this means are horizontally arranged. For instance, an AEA which is trading goods, could subscribe to more than one , where each corresponds to a different trading strategy. The framework places no limits on the complexity of . They can implement simple (e.g. ) logic or be complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default , called . Additional can be added as packages. For more details on head over to the <a href=""../skill""> guide </a>. ,Agent Loop: The <a href=""../api/agent_loop#baseagentloop-objects""></a> performs a series of activities while the state is not . - it calls the function of all active registered at their respective tick rate. - it grabs all Envelopes waiting in the queue and calls the function for the currently registered against the of the . - it dispatches the internal from the decision maker (described below) to the handler in the relevant . The <a href=""../api/agent_loop#baseagentloop-objects""></a> and <a href=""../api/multiplexer#multiplexer-objects""></a> are decoupled via the <a href=""../api/multiplexer#inbox-objects""></a> and <a href=""../api/multiplexer#outbox-objects""></a>, and both are maintained by the <a href=""../api/runtime#baseruntime-objects""></a>."
Core Components - Part 1,"Next Steps. ,Recommended: We recommend you continue with the next step in the 'Getting Started' series: - <a href=""../aea-vs-mvc"">AEA and web frameworks</a> ,Relevant Deep-Dives: Most AEA development focuses on developing the and necessary for an AEA to deliver against its economic objectives. Understanding is core to developing your own agent. You can learn more about the agents use to communicate with each other and how they are created in the following section: - <a href=""../protocol"">Protocols</a> Most of an AEA developer's time is spent on development. are the core business logic components of an AEA. Check out the following guide to learn more: - <a href=""../skill"">Skills</a> In most cases, one of the available packages can be used. Occasionally, you might develop your own : - <a href=""../connection"">Connections</a>"
ML Skills,"ML Skills. # ML Skills The AEA ML (machine learning) skills demonstrate an interaction between two AEAs, one purchasing data from the other and training a machine learning model with it. There are two types of AEAs: - The which sells training data. - The which purchases data and trains a model"
ML Skills,"Discussion. This demo aims to demonstrate the integration of a simple AEA with machine learning using the AEA framework. The AEA provides some sample data and delivers to the client upon payment. Once the client receives the data, it trains a model. This process can be found in . This demo does not utilize a smart contract. As a result, the ledger interaction is only for completing a transaction. Since the AEA framework enables using third-party libraries from PyPI, we can directly reference any external dependencies. The command installs all dependencies an AEA needs that is listed in one of its skills' YAML file."
ML Skills,Communication. This diagram shows the communication between the two AEAs.
ML Skills,"Option 1: AEA Manager Approach. ,Preparation Instructions: - Install the <a href=""https://aea-manager.fetch.ai"" target=""_blank"">AEA Manager</a>. - Install <a href=""https://www.tensorflow.org/install/"" target=""_blank"">Tensorflow</a> ,Demo Instructions: The following steps assume you have launched the AEA Manager Desktop app. 1. Add a new AEA called with public id . 2. Add another new AEA called with public id . 3. Copy the address from the into your clip board. Then go to the <a href=""https://explore-dorado.fetch.ai"" target=""_blank"">Dorado block explorer</a> and request some test tokens via . 4. Run the AEA. Navigate to its logs and copy the multiaddress displayed. 5. Navigate to the settings of the and under update as follows (make sure to replace the placeholder with the multiaddress): 6. Run the . In the AEA's logs, you should see the agents trading successfully, and the training agent training its machine learning model using the data purchased. The trainer keeps purchasing data and training its model until stopped."
ML Skills,"Option 2: CLI Approach. ,Preparation Instructions: #### Dependencies - Follow the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start. - Install <a href=""https://www.tensorflow.org/install/"" target=""_blank"">Tensorflow</a> ,Demo Instructions: #### Create Data Provider AEA First, fetch the data provider AEA: ??? note ""Alternatively, create from scratch:"" The following steps create the data provider from scratch: #### Create Model Trainer AEA Then, fetch the model trainer AEA: ??? note ""Alternatively, create from scratch:"" The following steps create the model trainer from scratch: #### Add Keys for the Data Provider AEA First, create the private key for the data provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: #### Add Keys and Generate Wealth for the Model Trainer AEA The model trainer needs to have some wealth to purchase the data from the data provider. First, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Then, create some wealth for your model trainer based on the network you want to transact with. On the Fetch.ai network: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: #### Run both AEAs Run both AEAs from their respective terminals. First, run the data provider AEA: Once you see a message of the form take note of the address. (Alternatively, use to retrieve the address.) This is the entry peer address for the local <a href=""../acn"">agent communication network</a> created by the ML data provider. Then, in the ML model trainer, run this command (replace with the correct value as described above): This allows the model trainer to connect to the same local agent communication network as the data provider. Then run the model trainer AEA: You can see that the AEAs find each other, negotiate and eventually trade. After the trade, the model trainer AEA trains its ML model using the data it has purchased. This AEA keeps purchasing data and training its model until stopped. #### Cleaning up When you're finished, delete your AEAs:"
Generic Skills,Generic Skills. # Generic Skills The AEA generic buyer and seller skills demonstrate an interaction between two AEAs: - An AEA that provides a (data selling) service. - An AEA that demands this service.
Generic Skills,"Discussion. The scope of this guide is demonstrating how to create easily configurable AEAs. The buyer AEA finds the seller, negotiates the terms of trade, and if successful purchases the data by sending payment. The seller AEA sells the service specified in its file, delivering it to the buyer upon receiving payment. Note that these agents do not utilize a smart contract but interact with a ledger to complete a transaction. Moreover, in this setup, the buyer agent has to trust the seller to send the data upon successful payment. The corresponding packages can be customised to allow for a database or sensor to be defined from which data is loaded. This is done by first modifying the variable in file of the skill to . Then you have to provide an implementation for the method in the file. More detailed instructions is beyond the scope of this guide."
Generic Skills,Communication. The following diagram shows the communication between various entities in this interaction.
Generic Skills,"Preparation Instructions. ,Dependencies: Follow the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start."
Generic Skills,"Demo Instructions. ,Create the Seller AEA: First, fetch the seller AEA: ??? note ""Alternatively, create from scratch:"" The following steps create the seller from scratch: ,Create the Buyer AEA: Then, in another terminal fetch the buyer AEA: ??? note ""Alternatively, create from scratch:"" The following steps create the buyer from scratch: ,Add Keys for the Seller AEA: Create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: ,Add Keys and Generate Wealth for the Buyer AEA: The buyer needs to have some wealth to purchase the data from the seller. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Then, create some wealth for your buyer based on the network you want to transact with. On the Fetch.ai network: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: ,Update the Skill Configurations:,Update the Skill Configurations: Both skills are abstract skills, make them instantiable:"
Generic Skills,"Run the AEAs. First, run the seller AEA: Once you see a message of the form take note of this address. (Alternatively, use to retrieve the address.) This is the entry peer address for the local <a href=""../acn"">agent communication network</a> created by the seller. Then, configure the buyer to connect to this same local ACN by running the following command in the buyer terminal, replacing with the value you noted above: Then run the buyer AEA: You will see that the AEAs negotiate and then transact using the Fetch.ai testnet."
Generic Skills,"Delete the AEAs. When you're done, stop the agents (), go up a level and delete the AEAs."
Decision Maker,"Decision Maker. # Decision Maker The <a href=""../api/decision_maker/base#decisionmaker-objects""></a> can be thought of like a wallet manager plus ""economic brain"" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component which has access to the wallet's private keys."
Decision Maker,"Interaction with Skills. Skills communicate with the decision maker via <a href=""../api/protocols/base#message-objects""></a>. At present, the decision maker processes messages of two protocols: - <a href=""../api/protocols/signing/message#signingmessage-objects""></a>: it is used by skills to propose a transaction to the decision-maker for signing. - <a href=""../api/protocols/state_update/message#stateupdatemessage-objects""></a>: it is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place. A message, say , is sent to the decision maker like so from any skill: The decision maker processes messages and can accept or reject them. To process from the decision maker in a given skill you need to create a , in particular a like so:"
Decision Maker,"Custom . The framework implements a default <a href=""../api/decision_maker/default#decisionmakerhandler-objects""></a> and an advanced <a href=""../api/decision_maker/gop#decisionmakerhandler-objects""></a>. You can also implement your own and mount it. No further configuration is needed to use the default. To use the advanced decision maker handler, add the following configuration to the of your AEA (on page 1): The easiest way to add a custom decision maker handler is to run the following command to scaffold a custom : You can then implement your own custom logic to process messages and interact with the . !!! note For examples how to use these concepts have a look at the skills. These functionalities are experimental and subject to change."
Testing Skills,"Testing Skills. # Testing Skills In this guide, we describe some of the tools the framework offers for testing skills."
Testing Skills,"The  Class. ,Specifying Skill Path: You must then specify the path to your skill directory via to allow the skill to be loaded and tested. This must be the directory in which of your skill resides. ,Setting up Each Test: You can add a class method to set the environment up for each of your tests. This code will be executed before every test method. If you do include this method, you must call the method of the class via . In the above, we make the behaviour object accessible for every test. ,Skill and Skill Context: The skill object itself is exposed via a property. So you can access the skill object by and by extension all of its attributes. This crucially includes the complete . This means that for example, every component of the skill (e.g. behaviours, handlers, models) can be accessed via the skill context. In the above code snippet, is accessed and exposed as a class attribute. Note accessing the skill context is slightly different in the above because it is a class method. If this was a test method, you could access the behaviour via . ,Dummy Agent Context: The loaded skill is also fed a dummy complete with an , , and so on, to allow the skill to be properly loaded and have access to everything it requires to function. The object fed to the skill is shown below: ,Some Useful Skill Attributes: Some of the useful objects you can access in your test class for the loaded skill are below: - : this is the agent identity the skill uses and is set to . - : this is the address of the search service and is set to . - : this is the id of the skill. - : this is the address of the decision maker and is set to . ,Some Useful Methods: There are a number of methods that offers to make testing skills easier. Some of these are mentioned below. For the rest, consult the API for : - : gives you the number of messages which are in the outbox. After running a part of the skill which is expected to send messages, you can use this method to assert the correct number of messages are indeed sent. - : gives you the last message in the outbox. Together with the above, you can use this method to grab the last message sent by the skill code you tested and check this is indeed the expected message. - : you can use this method in tandem with the above method to check that a message has the attributes you expect it to have. You have to supply it with the actual message (e.g. using ), specify its expected type (e.g. ), and any other attribute you expect the message to have (e.g. is 1) may be provided via keyword arguments. - : this is an especially useful method to test handlers. Since handlers handle incoming messages, you can create an incoming message using this method to feed it to the handler and test its execution. #### Checking Logger Output You can check the output of your skill's by mocking it using before executing a part of your skill as such: In the above, we mock the logger before running 's method and check that the string is indeed passed to the logger."
Testing Skills,"Next Steps. You can consult the and skills and their associated tests <a href=""https://github.com/fetchai/agents-aea/tree/main/tests/test_packages/test_skills"" target=""_blank"">here</a> to study how can help you in testing your skills. You can also refer to the API to study the different methods makes available to make testing your skills easier."
Gym Example,Gym Example. # Gym Example The example demonstrates the AEA framework's flexibility with respect to Reinforcement Learning using OpenAI's framework.
Gym Example,"Discussion. There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the allowing them to run in separate execution environments, potentially owned by different entities."
Gym Example,"Preparation Instructions. ,Dependencies: Follow the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start. Download the necessary directories into your working directory: Install the and library."
Gym Example,"Demo Instructions. ,Run the Example: Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment!"
Design Principles,"Design Principles. # Design Principles The AEA framework development is guided by the following 8 principles: - **Accessibility**: ease of use. - **Modularity**: encourages module creation, sharing and reuse. - **Openness**: easily extensible with third-party libraries. - **Conciseness**: conceptually simple. - **Value-driven**: drives immediate value. - **Low entry barriers**: leverages existing programming languages and web protocols. - **Safety**: safe for the user (economically speaking). - **Goal-alignment**: seamless facilitation of users' preferences and goals."
Performance Benchmark,Performance Benchmark. # Performance Benchmark Test AEA framework performance.
Performance Benchmark,"What is it?. The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results."
Performance Benchmark,How does it Work?. The framework: - spawns a dedicated process for each test run to execute the function to test. - measures CPU and RAM usage periodically. - waits for function exits or terminates them by timeout. - repeats test execution multiple times to get more accurate results.
Performance Benchmark,"How to Use. ,Simple Example: - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution. Run it with to get help about usage. run_time,sleep10,0.0001 Run it with to start with default parameters. [10, 0.0001] Here you can see test report for default arguments set. Run with multiple arguments set, multiple repeats and draw a chart on resources Report is: (3, 1e-05)(3, 0.001)(3, 0.01) Chart is drawn for argument 1: sleep: <img src=""../assets/benchmark_chart.png"" alt=""Char over argument 1 - sleep value"" class=""center""> The most interesting part is CPU usage, as you can see CPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution."
Performance Benchmark,"Requirements for Tested Function. - The first function's argument has to be which is passed by default by the framework. - All arguments except the fist one have to set default values. - Function doc string is required, it used for help information. - has to be called once in the function body to start measurement. The timeout is counted from this point! - All the ""prepare part"" in the function that should not be measured has to be placed before - Code to be measured has to go after - Try to avoid infinitive loops and assume the test should exit after a while."
Performance Benchmark,"Execution Options. - To pass an arguments set just provide it as a comma separated string like - To pass several argument sets just separate them by white space - is test execution timeout in seconds. If the test takes more time, it will be terminated. - is measurement interval in seconds, how often to make CPU and RAM usage measurements. - - how many times to run the same argument set to make result more accurate. - - Draw a chart, using values in the argument on the X axis, argument positions started with 0, argument benchmark not counted. For example will use values, will use values, and so on."
Performance Benchmark,"Limitations. Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests. Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually."
Performance Benchmark,"Testing AEA: Handlers Example. Test react speed on specific messages amount. Create AEA wrapper with specified handler: Populate inbox with dummy messages: Set timeout , for maximum messages processing speed: Start benchmark: Start/stop AEA: Wait till messages present in inbox:"
Application Areas,Application Areas. # Application Areas
Application Areas,"Environments. AEAs are most suited for environments which are: - **Decentralized**: there isn't a central authority that controls, manages, or makes decisions. - **Multi-Stakeholder**: the domain, problem, or solutions involve multiple distinct stakeholders. - **Peer-to-Peer**: interactions are (or could be made) direct and peer-to-peer. - **Complex, Incomplete, and Uncertain**: to the point that off-loading tasks to computational entities becomes valuable."
Application Areas,"Applications. We identify a number of application areas for AEA-based solutions. This list is by no means comprehensive. In fact, we are most excited about applications which we have not thought of before. **Automation** : AEAs can automate well-defined processes in different domains, such as supply chain, mobility, finance, ... **Micro-transactions** : AEAs make it economically viable to execute trade involving small values. An example is use-cases with many small sellers (e.g. of data) on the supply side. **Wallet** : AEAs can simplify interactions with blockchains. By acting as ""smart wallets"", they can hide away the majority of the complexities involved in using blockchains for end users. **IoT** : Agents representing objects in the IoT (Internet of Things) space. For example, AEAs paired with hardware devices such as drones, laptops, heat sensors, etc., providing control and receiving data from the device. An example is a <a href=""../thermometer-skills""> thermometer agent</a>. **Web 2.0 <--> Web 3.0 interface** : Agents that interface and bridge the gap between existing (Web 2.0) and new (Web 3.0) economic models. An example is an <a href=""../http-connection-and-skill""> AEA that communicates with HTTP clients/servers</a>. **Digital data sales** : Agents with access to some data sources that sell the data, access to the data, or access to the usage of the data. An example is an <a href=""../ml-skills"">AEA that continuously sells data to another AEA</a>, who in turn uses it to improve their reinforcement learning model."
Application Areas,"Multi-Agent System VS Agent-Based Modelling. The AEA framework enables the creation of multi-agent systems as technological solutions to real world problems. Although there are some overlap, the framework is not designed from the outset as an agent-based modelling software, where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to _multi_; single-agent applications are also supported."
Protocols,"Protocols. # Protocols <a href=""../api/protocols/base#protocol-objects""></a> define the structure of agent-to-agent and component-to-component interactions, which in the AEA world, are in the form of communication. To learn more about interactions and interaction protocols, see <a href=""../interaction-protocol"">here</a>. Protocols in the AEA world provide definitions for: - defining the structure and syntax of messages; - defining how a message is encoded/decoded for transport; and optionally - defining the structure of dialogues formed from exchanging series of messages. <img src=""../assets/protocol.jpg"" alt=""Protocol simplified"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:80%;""> The framework provides a protocol. This protocol provides a bare-bones implementation for an AEA protocol which includes a <a href=""../api/protocols/default/message#packages.fetchai.protocols.default.message""></a> class and associated <a href=""../api/protocols/default/serialization#packages.fetchai.protocols.default.serialization""></a> and <a href=""../api/protocols/default/dialogues#packages.fetchai.protocols.default.dialogues""></a> classes. Additional protocols - i.e. a new type of interaction - can be added as packages or generated with the <a href=""../protocol-generator"">protocol generator</a>. We highly recommend you to **not** attempt writing your protocol manually as they tend to have involved logic; always use existing packages or the protocol generator!"
Protocols,"Components of a Protocol. A protocol package contains the following files: - - , which defines message representation - , which defines the encoding and decoding logic - two protobuf related files It optionally also contains - , which defines the structure of dialogues formed from the exchange of a series of messages - , which defines custom types All protocols are for point to point interactions between two agents or agent-like services."
Protocols,"Metadata. Each in an interaction protocol has a set of default fields: - , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. The default value is . - , the identifier of the message in a dialogue. The default value is . - , the id of the message this message is replying to. The default value is . - , the purpose/intention of the message. - , the address of the sender of this message. - , the address of the receiver of this message. The default values for and assume the message is the first message in a dialogue. Therefore, the is set to indicating the first message in the dialogue and is since the first message is the only message that does not reply to any other. By default, the values of , , are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the allows different interactions to be identified as such. The and are used to keep track of messages and their replies. For instance, on receiving of a message with and , the responding agent could respond with another with and replying to the first message. In particular, holds the id of the message being replied to. This can be the preceding message, or an older one."
Protocols,Contents. Each message may optionally have any number of contents of varying types.
Protocols,"Dialogue Rules. Protocols can optionally have a dialogue module. A _dialogue_, respectively _dialogues_ object, maintains the state of a single, respectively, all dialogues associated with a protocol. The framework provides a number of helpful classes which implement most of the logic to maintain dialogues, namely the <a href=""../api/protocols/dialogue/base#dialogue-objects""></a> and <a href=""../api/protocols/dialogue/base#dialogues-objects""></a> base classes."
Protocols,"Custom Protocol. ,Fipa Dialogue: Below, we give an example of a dialogue between two agents. In practice; both dialogues would be maintained in the respective agent. We first create concrete implementations of and for the buyer and seller: Next, we can imitate a dialogue between the buyer and the seller. We first instantiate the dialogues models: First, the buyer creates a message destined for the seller and updates the dialogues: If the message has been correctly constructed, the will be returned, otherwise it will be . In a skill, the message could now be sent: However, here we simply continue with the seller: In the skill, the above two lines will be done by the framework; you can simply receive the message in the handler. We update the seller's dialogues model next to generate a new dialogue: Next, the seller can generate a proposal: In a skill, the message could now be sent: The dialogue can continue like this. To retrieve a dialogue for a given message, we can do the following:"
Protocols," Protocol. ,Fipa Dialogue: Below, we give an example of a dialogue between two agents. In practice; both dialogues would be maintained in the respective agent. We first create concrete implementations of and for the buyer and seller: Next, we can imitate a dialogue between the buyer and the seller. We first instantiate the dialogues models: First, the buyer creates a message destined for the seller and updates the dialogues: If the message has been correctly constructed, the will be returned, otherwise it will be . In a skill, the message could now be sent: However, here we simply continue with the seller: In the skill, the above two lines will be done by the framework; you can simply receive the message in the handler. We update the seller's dialogues model next to generate a new dialogue: Next, the seller can generate a proposal: In a skill, the message could now be sent: The dialogue can continue like this. To retrieve a dialogue for a given message, we can do the following:"
