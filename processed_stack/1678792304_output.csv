title,text
Autonomous Economic Agents (AEAs),"Autonomous Economic Agents (AEAs). # Autonomous Economic Agents (AEAs) <iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/xpJA4IT5X88"" frameborder=""0"" allow=""accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>"
Autonomous Economic Agents (AEAs),"What is an AEA?. ,What is NOT an AEA?: * **Any agent**: AEAs are NOT meant to address _any_ needs their owners might have. They have a clear and well-defined focus, which is generating economic value for their owner and this is manifested in a variety of different ways in their design. * **Digital twins**: An AEA is NOT it's owner's twin in the digital world; i.e. mirroring their preferences, values, and priorities. An AEA can be given whatever preference, value, and priority its owner wants them to have. * **APIs or Sensors**: These do NOT have any agency, nor proactiveness. They just ""sit there"" and respond to requests or changes in the environment. * **Smart contracts**: Similar to APIs and sensors, smart contracts do NOT display any proactiveness; they are purely reactive to external requests (in their case, contract calls and transactions). * An agent with **Artificial General Intelligence (AGI)**: AEAs have a well-defined, narrow, and goal directed focus that involves some economic gain. !!! info ""Agents and AEAs"" In the rest of the documentation, unless specified, we use the terms **AEA** and **Agent** interchangeably to mean AEA as defined above description."
AEAs vs Agents,"AEAs vs Agents. # AEAs vs Agents AEAs are more than just agents. <img src=""../assets/aea-vs-agent-vs-multiplexer.jpg"" alt=""AEA vs Agent vs Multiplexer"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:100%;""> In this guide, we show some of the differences in terms of code. The <a href=""../build-aea-programmatically"">Build an AEA programmatically</a> guide shows how to programmatically build an AEA. We can build an agent of the <a href=""../api/agent#agent-objects""></a> class programmatically as well. First, import the python and application specific libraries. (Get the directory from the AEA repository .) Unlike an , an does not require a , or module. However, we need to implement 4 abstract methods: - - - - When we run an agent, calls and then the main agent loop. The main agent loop calls , and on each tick. When the agent is stopped via then is called. Such a lightweight agent can be used to implement simple logic."
AEAs vs Agents,"Code an . We define our which simply receives envelopes, prints the sender address and and returns it unopened."
AEAs vs Agents,Instantiate an . 
AEAs vs Agents,Start the Agent. We run the agent from a different thread so that we can still use the main thread to pass it messages.
AEAs vs Agents,Send and Receive an Envelope. We use the input and output text files to send an envelope to our agent and receive a response
AEAs vs Agents,"Shutdown. Finally, stop our agent and wait for it to finish"
AEAs vs Agents,Your Turn. Now it is your turn to develop a simple agent with the class.
AEAs vs Agents,"Entire Code Listing. If you just want to copy and paste the entire script in you can find it here: ??? note ""Click here to see full listing"""
Debugging,Debugging. # Debugging There are multiple ways in which to configure your AEA for debugging during development. We focus on the standard Python approach here.
Debugging,"Using  stdlib. You can add a debugger anywhere in your code: Then simply run you AEA with the mode: For more guidance on how to use check out <a href=""https://docs.python.org/3/library/pdb.html"" target=""_blank"">the documentation</a>."
Debugging,Using an IDE. - For VSCode modify the to include the following information: where should be replaced with the path to the virtual environment and with the working directory for the agent to debug (where the file is).
Core components - Part 2,"Core components - Part 2. # Core components - Part 2 The AEA framework consists of several core components, some required to run an AEA and others optional. In <a href=""../core-components-1"">Core Components - Part 1</a> we described the common components each AEA uses. In this page, we will look at more advanced components."
Core components - Part 2,"Required Components Used by AEAs. ,Decision Maker: of an AEA"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:50%;""> The <a href=""../api/decision_maker/base#decisionmaker-objects""></a> can be thought of as a manager plus ""economic brain"" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component with access to the 's private keys. You can learn more about the decision maker <a href=""../decision-maker"">here</a>. In its simplest form, the decision maker acts like a with that reacts to the messages it receives from the skills. ,Wallet: The <a href=""../api/crypto/wallet#wallet-objects""></a> contains the private-public key pairs used by the AEA. Skills do not have access to the wallet, only the decision maker does. The agent has two sets of private keys, as configured in the : - : This is a dictionary mapping identifiers to the file paths of private keys used in the AEA. For each identifier, e.g. , the AEA can have one private key. The private keys listed here are available in the and the associated public keys and addresses are available in all skills. The AEA uses these keys to sign transactions and messages. These keys usually hold the AEAs funds. - : This is a dictionary mapping identifiers to the file paths of private keys used in connections. For each identifier, e.g. , the can have one private key. The private keys listed here are available in the connections. The connections use these keys to secure message transport, for instance. It is the responsibility of the AEA's user to safeguard the keys used and ensure that keys are only used in a single AEA. Using the same key across different AEAs will lead to various failure modes. Private keys can be encrypted at rest. The CLI commands used for interacting with the wallet allow specifying a password for encryption/decryption. ,Identity: The <a href=""../api/identity/base#identity-objects""></a> is an abstraction that represents the identity of an AEA in the Open Economic Framework, backed by public-key cryptography. It contains the AEA's addresses as well as its name. The identity can be accessed in a via the <a href=""../api/context/base#agentcontext-objects""></a>."
Core components - Part 2,"Optional Components Used by AEAs. ,Contracts: of an AEA"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:50%;""> <a href=""../api/contracts/base#contract-objects""></a> wrap smart contracts for third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract. They expose an API to abstract implementation specifics of the ABI from the . usually contain the logic to create contract transactions and make contract calls. can be added as packages. For more details on also read the guide <a href=""../contract"">here</a>."
Core components - Part 2,"Putting it Together. Taken together, the core components from this section and the <a href=""../core-components-1"">first part</a> provide the following simplified illustration of an AEA: <img src=""../assets/simplified-aea.jpg"" alt=""Simplified illustration of an AEA"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:100%;"">"
Core components - Part 2,"Next Steps. ,Recommended: We recommend you continue with the next step in the 'Getting Started' series: - <a href=""../interaction-protocol"">How AEAs talk to each other - Interaction protocols</a> ,Relevant Deep-Dives: Understanding the decision maker is vital to developing a goal oriented and crypto-economically safe AEA. You can learn more about the in the following section: - <a href=""../decision-maker"">Decision Maker</a> Understanding is important when developing AEAs that make commitments or use smart contracts for other purposes. You can learn more about the agents use in the following section: - <a href=""../contract"">Contracts</a>"
Build your First Skill - Search & Discovery,"Build your First Skill - Search & Discovery. # Build your First Skill - Search & Discovery This guide will take you through the development of your first skill. It will teach you, how to connect the AEA to the digital world, register the AEA and search for other AEAs. Although one can imagine scenarios where a single AEA pursues its goals in isolation without interacting with other AEAs, there is no doubt that by working together, AEAs can achieve much more. To do so, an AEA must be seen and found by other AEAs so that they can trade and do other useful things. Fetch.ai’s search-and-discovery mechanism, the <a href=""../simple-oef"">simple OEF</a> (or SOEF, for short) lets your agents register, be discovered, and find other agents. You can then negotiate using the AEA framework’s <a href=""../acn"">peer-to-peer network (ACN)</a> and trade. This guide covers getting your AEA connected to the SOEF, and describing your AEA to make itself visible. Registering your AEA with the SOEF involves setting a name, a genus (a high-level description of what the agent represents, e.g. , or ), a classification (for example ) and other descriptors to further fine-tune the kind of service your AEA offers (for example, the agent's position, whether it buys or sells, and other descriptive items). The more you describe your AEA, the easier it is for others to find it using specific filters."
Build your First Skill - Search & Discovery,"Dependencies (Required). Follow the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start."
Build your First Skill - Search & Discovery,"Step 1: Setup. We will first create an AEA and add a scaffold skill, which we call . In the following steps, we replace the scaffolded and in with our implementation. We will build a simple skill which lets the AEA send a search query to the <a href=""../simple-oef"">SOEF search node</a> and process the resulting response."
Build your First Skill - Search & Discovery,"Step 2: Develop a Behaviour. A <a href=""../api/skills/base#behaviour-objects""></a> class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, gets called by the main agent loop, we will send a search request to the <a href=""../simple-oef"">SOEF search node</a> via the <a href=""../acn"">P2P communication network</a>. Searches are proactive and, as such, well placed in a <a href=""../api/skills/base#behaviour-objects""></a>. Specifically, we subclass the <a href=""../api/skills/behaviours#tickerbehaviour-objects""></a> as it allows us to repeatedly search at a defined tick interval. We place this code in . Ensure you replace the author in this line with your author handle (run to set or check the author name). !!! note The import paths to agent packages, for example above, are not actual paths. Package files always reside in your AEA's folder, either under a specific package directory (e.g. connection, protocol, skill) if the package is custom-built, or under if it is pulled from the registry. These paths are virtual and created automatically when an AEA is run. See <a href=""../package-imports""> this page </a> for more details."
Build your First Skill - Search & Discovery,"Step 3: Develop a Handler. So far, we have tasked the AEA with sending search requests to the <a href=""../simple-oef"">SOEF search node</a>. However, we have no way of handling the responses sent to the AEA by the <a href=""../simple-oef"">SOEF search node</a> at the moment. The AEA would simply respond to the <a href=""../simple-oef"">SOEF search node</a> via the default skill which sends all unrecognised envelopes back to the sender. Let us now implement a <a href=""../api/skills/base#handler-objects""></a> to deal with the incoming search responses. We create a handler which is registered for the protocol. Whenever it receives a search result, we log the number of agents returned by the search - the agents matching the search query - and update the counter of received searches. We also implement a trivial check on the difference between the amount of search requests sent and responses received. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. Also note, how we have access to other objects in the skill via , the <a href=""../api/skills/base#skillcontext-objects""></a>. We place this code in . Ensure you replace the author in this line with your author handle (run to set or check the author name)."
Build your First Skill - Search & Discovery,"Step 4: Add Dialogues Model. We have implemented a behaviour and a handler. We now implement a <a href=""../api/skills/base#model-objects""></a>, in particular we implement the <a href=""../api/protocols/dialogue/base#dialogue-objects""></a> and <a href=""../api/protocols/dialogue/base#dialogues-objects""></a> classes. These ensure that the message flow satisfies the protocol and keep track of the individual messages being sent and received. We add this code in the file , replacing its original content. We then rename to ."
Build your First Skill - Search & Discovery,"Step 5: Create the Configuration File. Based on our skill components above, we create the following configuration file. Ensure, you replace the author field with your author name! (Run to set or check the author name.) Importantly, the keys and are used in the above handler to access these skill components at runtime via the context. We also set the of the to seconds. We place this code in . Similarly, we replace as follows: Again, ensure the author field matches your own."
Build your First Skill - Search & Discovery,"Step 6: Update Fingerprint. To run an AEA with new or modified code, you need to update the fingerprint of the new/modified components. In this case, we need to fingerprint our skill: Ensure, you use the correct author name to reference your skill (here we use as the author.)"
Build your First Skill - Search & Discovery,"Step 7: Add the OEF Protocol and Connection. Our AEA does not have the OEF protocol yet so let's add it. This adds the protocol to our AEA and makes it available on the path . At this point we need to add the SOEF and P2P connections to allow the AEA to communicate with the SOEF node and other AEAs, install the AEA's dependencies, and configure the AEA: The last command will ensure that search requests are processed by the correct connection."
Build your First Skill - Search & Discovery,"Step 8: Run a Service Provider AEA. In order for this AEA to find another AEA when searching, the second AEA (let's call it the service provider AEA) must exist and have been registered with the SOEF. From a different terminal window, we fetch a finished service provider AEA and install its Python dependencies: This AEA will simply register a location service on the <a href=""../simple-oef"">SOEF search node</a> so we can search for it. We first create the private key for the service provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: Then we run the AEA: Once you see a message of the form take note of the address. (Alternatively, use to retrieve the address.) This is the entry peer address for the local <a href=""../acn"">agent communication network</a> created by the (service provider) AEA. ??? note ""Click here to see full code and guide for this AEA:"" We use a <a href=""../api/skills/behaviours#tickerbehaviour-objects""></a> to update the service registration at regular intervals. The following code is placed in . We create a <a href=""../api/skills/base#model-objects""><code>Model</code></a> type strategy class and place it in <code>strategy.py</code>. We use a generic data model to register the service. As part of the registration we register a location and a key pair describing our service. keyvaluekeyvaluekeyvalue We create a <a href=""../api/skills/base#model-objects""><code>Model</code></a> type dialogue class and place it in <code>dialogues.py</code>. These classes ensure that the message flow satisfies the <code>fetchai/oef_search:1.0.0</code> protocol and keep track of the individual messages being sent and received. Finally, we have a handler, placed in <code>handlers.py</code>. The handler deals with handling any error messages which might occur during service registration: The associated <code>skill.yaml</code> is:"
Build your First Skill - Search & Discovery,"Step 9: Run the Search AEA. First, create the private key for the search AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: Then, in the search AEA, run this command (replace with the correct value as described above): This allows the search AEA to connect to the same local agent communication network as the service registration AEA. We can then launch our AEA. We can see that the AEA sends search requests to the <a href=""../simple-oef"">SOEF search node</a> and receives search responses from the <a href=""../simple-oef"">SOEF search node</a>. The search response returns one or more agents (the service provider and potentially other agents which match the query). We stop the AEA with ."
Build your First Skill - Search & Discovery,"Next Steps. ,Recommended: We recommend you continue with the next step in the 'Getting Started' series: - <a href=""../core-components-2"">Core components (Part 2)</a> ,Relevant Deep-Dives: <a href=""../generic-skills-step-by-step""> This guide </a> goes through a more elaborate scenario than the one on this page, where after finding each other, the two AEAs negotiate and trade via a ledger."
Build an AEA on a Raspberry Pi,Build an AEA on a Raspberry Pi. # Build an AEA on a Raspberry Pi This guide explains how to run an AEA inside a Raspberry Pi.
Build an AEA on a Raspberry Pi,"Prerequisites. - <a href=""https://thepihut.com/products/raspberry-pi-4-model-b?gclid=EAIaIQobChMImcuwvcfh4wIVirHtCh3szg2EEAAYASAAEgJQ_fD_BwE"" target=""_blank"">Raspberry Pi 4</a> (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) - Internet connection (preferably wireless to minimise the number of wires connecting into your device)"
Build an AEA on a Raspberry Pi,"Preparing the Raspberry Pi. The easiest and recommended way to get started is to download and unzip our custom <a href=""https://storage.googleapis.com/fetch-ai-aea-images/aea_rpi.img.tar.gz"" target=""_blank"">AEA Raspberry Pi Image</a>, which includes the AEA installation as well as the most common dependencies. However, you can also do the installation manually, and if you have a new Raspberry Pi, you can boot the system using the included SD card and skip the next section."
Build an AEA on a Raspberry Pi,"Raspberry Pi Imager. is a way to write to an SD card for easy installation on a Raspberry Pi. First download the tool from <a href=""https://www.raspberrypi.com/software/"" target=""_blank"">this link</a>. Then follow <a href=""https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up"" target=""_blank"">this guide</a> to set up your SD card. When you get to the step of choosing an operating system, select the downloaded and unzipped AEA Raspberry Pi Image (), or for a manual installation, select the latest Raspberry Pi OS. Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and boot up."
Build an AEA on a Raspberry Pi,"Booting up with the AEA Raspberry Pi Image. After booting up, you may be prompted to log in as the user and the password is . Next, navigate to settings menu to set up your internet connection. Your Raspberry Pi is now ready to run an AEA! You can find some preloaded demos in the folder . To run these demos, navigate to one of the sub-folders and enter ."
Build an AEA on a Raspberry Pi,"Booting up with the Raspberry Pi OS for Manual Installation. When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry Pi and your Wi-Fi password so the device can access the internet. You may also be given the option to update the operating system and software. We recommend that you let the system update. Once finished you will be prompted to restart. Even if your Raspberry Pi updated itself, we recommend that you make sure it is completely up-to-date using the terminal. Open a Terminal window (your Raspberry Pi might restart a few times during this process):"
Build an AEA on a Raspberry Pi,Install Common Dependencies. 
Build an AEA on a Raspberry Pi,"Install Less Common Dependencies (optional). For some of the more advanced AEAs that make use of SciPy, such as the Car Park Detector, you will need some additional dependencies. ??? note ""Install additional dependencies with the enclosed steps:"" Install additional dependencies Increase the swap space for the SciPy installation: Install NumPy and scikit-image (including SciPy) Revert to default swap space"
Build an AEA on a Raspberry Pi,"Install the AEA Framework. Add to the local environment variable (this will happen automatically the next time you log in): Finally, install the AEA framework from PyPI: Check to make sure installation was successful: Your Raspberry Pi is now ready to run an AEA!"
Create Stand-Alone Transaction,"Create Stand-Alone Transaction. # Create Stand-Alone Transaction In this guide, we will generate some wealth for the Fetch.ai testnet and create a standalone transaction. After the completion of the transaction, we get the transaction digest. With this we can search for the transaction on the <a href='https://explore-dorado.fetch.ai/' target=""_blank"">block explorer</a> This guide requires the plug-in installed in your Python environment: First, import the python and application specific libraries and set the static variables."
Create Stand-Alone Transaction,Create the Private Keys. 
Create Stand-Alone Transaction,Create the Wallets. Once we created the private keys we need to generate the wallets.
Create Stand-Alone Transaction,"Generate Wealth. Since we want to send funds from to , we need to generate some wealth for the . We can do this with the following code"
Create Stand-Alone Transaction,"Send Transaction. Finally, we create a transaction that sends the funds to the ??? note ""Stand-alone transaction full code:"""
Development Setup,"Development Setup. # Development Setup An AEA <a href=""../package-imports"">consists of packages </a>. When developing, it helps to be able to save packages in a local package registry, rather than pushing them to <a href=""https://aea-registry.fetch.ai"" target=""_blank"">remote registry</a>. This guide helps you set up a local package registry and configure the working directory for development. There are two ways to write code for an AEA: 1. independent of a concrete AEA project, write individual packages 2. from within an AEA project, write packages for that AEA"
Development Setup,"Approach 1. To prepare a directory (henceforth working directory) for development with the AEA framework you can take a few steps: - Either, manually: - Ensure you start with an empty working directory to avoid any unnecessary side effects. - In your working directory, create an empty folder called . This folder will act as the local registry for packages. - In your working directory, create a file with the constant where is the path to the folder in your working directory. - Or, automated: - Fork our <a href=""https://github.com/fetchai/agents-template"" target=""_blank"">template repo</a> for AEA development. Then clone it to your machine. - Depending on your editor, you might take further steps: - VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for which specifies the path to a file containing environment variable definitions. The default is set to . Provide the path to the file in the above settings. In the file, add the constant defined above. Then close VS Code and re-open it for the settings to take effect. After developing a package, you can add it to an AEA project in the working directory (e.g. will create a new AEA project and add the package of type with public id to it.)"
Development Setup,"Approach 2. It is also possible to develop directly in an AEA project: - Prepare a directory (henceforth working directory) for development. - Create a new project - Scaffold a new package . This will create the package scaffold under the directory and create symlinks to ensure package import paths line up with the folder structure. The symlinks are not needed to run the AEA. They are purely for your IDE. - In your working directory, create a file with the constant where is the path to the AEA project contained in your working directory. - Depending on your editor, you might take further steps: - VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for which specifies the path to a file containing environment variable definitions. The default is set to . Provide the path to the file in the above settings. In the file, add the constant defined above. Then close VS Code and re-open it for the settings to take effect."
Development Setup,"General Advice. This advice partially overlaps with the previous two sections: - When developing a specific AEA, it might be helpful to publish/push or fetch/add from local registry. From your working directory/AEA project, simply execute the usual AEA CLI commands. The CLI will first search in the directory, then in the remote AEA registry. You can explicitly point to local registry by providing flag or to only point to remote registry (see <a href=""../cli-commands"">here</a> for more details on CLI commands). - When working on an AEA, it may help to provide a symbolic link to the directory, so that the import paths are detected by your editor. Simply create an empty file with in your AEA project, then create a symbolic link to the directory with . - Alternatively, it can help to provide symbolic links within an AEA to align import paths with folder structure. Simply create an empty file with in your AEA project, then create a symbolic link to ."
Aries Cloud Agents Demo,Aries Cloud Agents Demo. # Aries Cloud Agents Demo !!! note This demo is incomplete and will soon be updated. Demonstrating an entire decentralized identity scenario involving AEAs and instances of Aries Cloud Agents (ACAs).
Aries Cloud Agents Demo,"Discussion. This demo corresponds with the one <a href=""https://github.com/hyperledger/aries-cloudagent-python/blob/main/demo/README.md"" target=""_blank"">here</a> from <a href=""https://github.com/hyperledger/aries-cloudagent-python"" target=""_blank""> Aries cloud agent repository </a>. The aim of this demo is to illustrate how AEAs can connect to ACAs, thus gaining all of their capabilities, such as issuing and requesting verifiable credentials, selective disclosure and zero knowledge proofs. There are two AEAs: - **Alice_AEA** - **Faber_AEA** and two ACAs: - **Alice_ACA** - **Faber_ACA** Each AEA is connected to its corresponding ACA: **Alice_AEA** to **Alice_ACA** and **Faber_AEA** to **Faber_ACA**. The following lists the sequence of interactions between the four agents: - **Alice_AEA**: starts - **Alice_AEA**: shows its P2P address in the terminal and waits for an detail from **Faber_AEA**. - **Alice_AEA**: registers itself on the SOEF. - **Faber_AEA**: starts - **Faber_AEA**: searches the SOEF and finds **Alice_AEA**. - **Faber_AEA**: tests its connection to **Faber_ACA**. - **Faber_ACA**: responds to **Faber_AEA**. - **Faber_AEA**: registers a DID on the ledger. - **Faber_AEA**: request **Faber_ACA** to register a schema on the ledger. - **Faber_ACA**: responds by sending back the . - **Faber_AEA**: request **Faber_ACA** to register a credential definition on the ledger. - **Faber_ACA**: responds by sending back the . - **Faber_AEA**: requests **Faber_ACA** to create an invitation. - **Faber_ACA**: responds by sending back the detail, which contains an field. - **Faber_AEA**: sends the detail to **Alice_AEA**. - **Alice_AEA**: receives detail from **Faber_AEA**. - **Alice_AEA**: requests **Alice_ACA** to accept the invitation, by passing it the detail it received in the last step. All messages from an AEA to an ACA are http requests (using connection). All messages from an AEA to another AEA utilise the P2P communication network accessed via the connection. All messages initiated from an ACA to an AEA are webhooks (using connection). This is the extent of the demo at this point. The rest of the interactions require an instance of the <a href=""https://github.com/bcgov/von-network"" target=""_blank"">Indy ledger</a> to run. This is what will be implemented next. The rest of the interactions are broadly as follows: - **Alice_ACA**: accepts the invitation. - **Alice_ACA**: sends a matching invitation request to **Faber_ACA**. - **Faber_ACA**: accepts At this point, the two ACAs are connected to each other. - **Faber_AEA**: requests **Faber_ACA** to issue a credential (e.g. university degree) to **Alice_AEA**, which **Faber_ACA** does via **Alice_ACA**. - **Faber_AEA**: requests proof that **Alice_AEA**'s age is above 18. - **Alice_AEA**: presents proof that it's age is above 18, without presenting its credential."
Aries Cloud Agents Demo,"Preparation Instructions. ,Dependencies: Follow the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start. Install Aries cloud-agents (for more info see <a href=""https://github.com/hyperledger/aries-cloudagent-python#install"" target=""_blank"">here</a>) if you do not have it on your machine: This demo has been successfully tested with version . This demo requires an instance of von network running in docker locally (for more info see <a href=""https://github.com/bcgov/von-network#running-the-network-locally"" target=""_blank"">here</a>) This demo has been successfully tested with the von-network git repository pulled on 07 Aug 2020 (commit number ). ,Terminals: Open five terminals. The first terminal is used to run an instance of von-network locally in docker. The other four terminals will be used to run each of the four agents in this demo."
Aries Cloud Agents Demo,"VON Network. In the first terminal move to the directory and run an instance of locally in docker. This <a href=""https://github.com/bcgov/von-network#running-the-network-locally"" target=""_blank"">tutorial</a> has information on starting (and stopping) the network locally. Once the ledger is running, you can see the ledger by going to the web server running on port 9000. On localhost, that means going to <a href=""http://localhost:9000"" target=""_blank"">http://localhost:9000</a>."
Aries Cloud Agents Demo,"Alice and Faber ACAs. ,Faber_ACA: In the first terminal: Make sure the ports above are unused. Take note of the specific IP addresses and ports you used in the above command. We will refer to them by the following names: - **Faber admin IP**: 127.0.0.1 - **Faber admin port**: 8021 - **Faber webhook port**: 8022 The admin IP and port will be used to send administrative commands to this ACA from an AEA. The webhook port is where the ACA will send notifications to. We will expose this from the AEA so it receives this ACA's notifications. ,Alice_ACA: In the second terminal: Again, make sure the above ports are unused and take note of the specific IP addresses and ports. In this case: - **Alice admin IP**: 127.0.0.1 - **Alice admin port**: 8031 - **Alice webhook port**: 8032"
Aries Cloud Agents Demo,"Alice and Faber AEAs. ,Alice_AEA:,Install the Dependencies and Run Alice_AEA:,Faber_AEA:,Install the Dependencies and Run Faber_AEA: Now install all the dependencies: Finally run **Faber_AEA**: You should see **Faber_AEA** running and showing logs of its activities. For example: <img src=""../assets/aries-demo-faber.png"" alt=""Aries demo: Faber terminal"" class=""center""> Looking now at **Alice_AEA** terminal, you should also see more activity by **Alice_AEA** after **Faber_AEA** was started. For example: <img src=""../assets/aries-demo-alice.png"" alt=""Aries demo: Alice terminal"" class=""center""> The last error line in **Alice_AEA**'s terminal is caused due to the absence of an Indy ledger instance. In the next update to this demo, this will be resolved."
Aries Cloud Agents Demo,"Terminate and Delete the Agents. You can terminate each agent by pressing Ctrl+C. To delete the AEAs, go to the projects' parent directory and delete the AEAs:"
Aries Cloud Agents Demo,"Further Developments. In the next update to this demo, the remaining interactions between AEAs and ACAs must be implemented. This means: - An instance of Indy ledger must be installed and running. See <a href=""https://github.com/bcgov/von-network#running-the-network-locally"" target=""_blank"">here</a> for more detail. - The commands for running the ACAs need to be adjusted. Additional options relating to a wallet (wallet-name, type, key, storage-type, configuration, credentials) need to be fed to the ACAs as well as the ledger's genesis file so the ACAs can connect to the ledger. - The remaining interactions between the AEAs and ACAs as described <a href=""../aries-cloud-agent-demo/#discussion"">here</a> need to be implemented."
Agent Ecosystem,"Agent Ecosystem. # Agent Ecosystem AEAs are situated within a larger ecosystem comprised of various other systems and technology layers. <img src=""../assets/oef-ledger.jpg"" alt=""The AEA, OEF, and Ledger systems"" class=""center"">"
Agent Ecosystem,"Agent Communication Network (ACN). ACN is a <a href=""../acn"">peer-to-peer communication network</a> for agents. It allows AEAs to send and receive envelopes between each other. The implementation builds on the open-source <a href=""https://libp2p.io/"" target=""_blank"">libp2p</a> library. A distributed hash table is used by all participating peers to maintain a mapping between agents' cryptographic addresses and their network addresses. Agents can receive messages from other agents if they are both connected to the ACN (see <a href=""../p2p-connection"">here</a> for an example)."
Agent Ecosystem,"Search and Discovery. An <a href=""../simple-oef"">sOEF node</a> allows agents to discover each other. In particular, agents can register themselves and the services they offer, and can search for agents who offer specific services. For two agents to be able to find each other, at least one must register itself on the sOEF and the other must query the sOEF node for it. Detailed documentation is provided <a href=""../simple-oef"">here</a>."
Agent Ecosystem,"Ledgers. ,AEAs as Second Layer Technology: The following presentation discusses how AEAs can be seen as second layer technology to ledgers. <iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/gvzYX7CYk-A"" frameborder=""0"" allow=""accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>"
