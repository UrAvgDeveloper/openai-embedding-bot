title,text
Limitations of v1,Limitations of v1. # Limitations of v1 This document describes some of the limitations of of the AEA framework and tradeoffs made in its design.
Limitations of v1,"Rejected Ideas. ,Handlers Implemented as Behaviours: Handlers can be considered a special cases of a ""behaviour that listens for specific events to happen"". One could implement classes in terms of , after having implemented the feature that behaviours can be activated after an event happens (e.g. receiving a message of a certain protocol). This was rejected in favour of a clear separation of concerns, and to avoid purely reactive (handlers) and proactive (behaviours) components to be conflated into one concept. The proposal would also add complexity to behaviour development. ,Multiple Versions of the Same Package: The framework does not allow for the usage of multiple versions of the same package in a given project. Although one could re-engineer the project to allow for this, it does introduce significant additional complexities. Furthermore, Python modules are by design only allowed to exist as one version in a given process. Hence, it seems sensible to maintain this approach in the AEA."
Limitations of v1,"Potential Extensions, Considered yet not Decided. ,Alternative Skill Design: For very simple skills, the splitting of skills into , , and classes can add unnecessary complexity to the framework and a counter-intuitive responsibility split. The splitting also implies the framework needs to introduce the object to allow for access to data across the skill. Furthermore, the framework requires implementing all functionality in classes , or . This approach is consistent and transparent, however it creates a lot of boilerplate code for simple skills. Hence, for some use cases it would be useful to have a single class with abstract methods , , and . Then the developer can decide how to split up their code. Alternatively, we could use decorators to let a developer define whether a function is part of a handler or behaviour. That way, a single file with a number of functions could implement a skill. (Behind the scenes this would utilise a number of virtual and classes provided by the framework). The downside of this approach is that it does not advocate for much modularity on the skill level. Part of the role of a framework is to propose a common way to do things. The above approach can cause for a larger degree of heterogeneity in the skill design which makes it harder for developers to understand each other's code. The separation between all four base classes does exist both in convention *and* at the code level. Handlers deal with skill-external events (messages), behaviours deal with scheduled events (ticks), models represent data and tasks are used to manage long-running business logic. By adopting strong convention around skill development we allow for the framework to take a more active role in providing guarantees. E.g. handlers' and behaviours' execution can be limited to avoid them being blocking, models can be persisted and recreated, tasks can be executed with different task backends. The opinionated approach is thought to allow for better scaling. ,Further Modularity for Skill Level Code: Currently, we have three levels of modularity: - PyPI packages - framework packages: protocols, contracts, connections and skills - framework plugins: CLI, ledger We could consider having a fourth level: common behaviours, handlers, models exposed as modules which can then speed up skill development. ,""promise"" Pattern: Given the asynchronous nature of the framework, it is often hard to implement reactions to specific messages, without making a ""fat"" handler. Take the example of a handler for a certain type of message for a certain protocol . The handler for protocol would look something like this: However, it could be helpful to overwrite this handler reaction with another callback (e.g. consider <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"" target=""_blank"">this in context</a>): This feature would introduce additional complexity for the framework to correctly wire up the callbacks and messages with the dialogues. ,CLI using Standard Lib: Removing the click dependency from the CLI would further reduce the dependencies in the AEA framework which is overall desirable. ,Metadata vs Configurations: The current approach uses files to specify both metadata and component configuration. It would be desirable to introduce the following separation: - package metadata - package default developer configuration - package default user configuration A user can only configure a subset of the configuration. The developer should be able to define these constraints for the user. Similarly, a developer cannot modify all fields in a package, some of them are determined by the framework. ,Configuring Agent Goal Setup: By default, the agent's goals are implicitly defined by its skills and the configurations thereof. This is because the default decision maker signs every message and transaction presented to it. It is already possible to design a custom decision maker. However, more work needs to be done to understand how to improve the usability and configuration of the decision maker. In this context different types of decision makers can be implemented for the developer/user. ,Connection Status Monitoring: Currently, connections are responsible for managing their own status after they have been ""connected"" by the . Developers writing connections must take care to properly set its connection status at all times and manage any disconnection. It would potentially be desirable to offer different policies to deal with connection problems on the multiplexer level: - disconnect one, keep others alive - disconnect all - try to reconnect indefinitely ,Agent Snapshots on Teardown or Error: Currently, the developer must implement snapshots on the component level. It would be desirable if the framework offered more help to persist the agent state on teardown or error. ,Dialogues Management: The current implementation of Dialogues is verbose. Developers often need to subclass and classes. More effort can be made to simplify and streamline dialogues management. ,Instantiate Multiple Instances of the Same Class of : Currently, configuration and metadata of a package are conflated making it not straightforward to run one package component with multiple sets of configuration. It could be desirable to configure an agent to run a given package with multiple different configurations. This feature could be problematic with respect to component-to-component messaging which currently relies on component ids, which are bound to the package and not its instance. ,Containerized Agents: Agent management, especially when many of them live on the same host, can be cumbersome. The framework should provide more utilities for these large-scale use cases. But a proper isolation of the agent environment is something that helps also simple use cases. A new software architecture, somehow inspired to the Docker system. The CLI only involves the initialization of the building of the agent (think of it as the specification of the : the ), but the actual build and run are done by the AEA engine, a daemon process analogous of the Docker Engine, which exposes APIs for these operations. Users and developers would potentially like to run many AEAs of different versions and with differences in the versions of their dependencies. It is not possible to import different versions of the same Python (PyPI) package in the same process in a clean way. However, in different processes this is trivial with virtual environments. It would be desirable to consider this in the context of a container solution for agents. ,Dependency Light Version of the AEA Framework: The of the Python AEA implementation makes every effort to minimise the amount of third-party dependencies. However, some dependencies remain to lower development time. It would be desirable to further reduce the dependencies, and potentially have an implementation that only relies on the Python standard library. This could be taken further, and a reduced spec version for <a href=""https://micropython.org"" target=""_blank"">micropython</a> could be designed. ,Compiled AEA: Python is not a compiled language. However, various projects attempt this, e.g. <a href=""https://nuitka.net/doc/user-manual.html"" target=""_blank"">Nuitka</a> and it would be desirable to explore how useful and practical this would be in the context of AEA. ,DID Integration: It would be great to integrate <a href=""https://www.w3.org/TR/did-core/"" target=""_blank"">DID</a> in the framework design, specifically identification of packages (most urgently protocols). Other projects and standards worth reviewing in the context (in particular with respect to identity): - <a href=""https://erc725alliance.org"" target=""_blank"">ERC 725: Ethereum Identity Standard</a> and <a href=""https://erc725alliance.org"" target=""_blank"">here</a>. - <a href=""https://github.com/ethereum/eips/issues/735"" target=""_blank"">ERC 735: Claim Holder</a> ,Optimise Protocol Schemas and Messages: The focus of protocol development was on extensibility and compatibility, not on optimisation. For instance, the dialogue references use inefficient string representations. ,Constraints on Primitive Types in Protocols: The protocol generator currently does not support custom constraints. The framework could add support for custom constraints for the protocol generator and specification. There are many types of constraints that could be supported in specification and generator. One could perhaps add support based on the popularity of specific constraints from users/developers. Example constraints: - strings following specific regular expression format (e.g. all lower case, any arbitrary regex format) - max number of elements on lists/sets - keys in one type be equal to keys in another type - other logical constraints, e.g. as supported in ontological languages - support for bounds (i.e. min, max) for numerical types (i.e. and ) in protocol specification. Example syntax: - - - - This would automatically enable support for signed/unsigned and . This syntax would allow for unbounded positive/negative/both, or arbitrary bounds to be placed on numerical types. Currently, the developer has to specify a custom type to implement any constraints on primitive types. ,Sub-protocols & Multi-Party Interactions: Protocols can be allowed to depend on each other. Similarly, protocols might have multiple parties. Furthermore, a turn-taking function that specifies who's turn it is at any given point in the dialogue could be added. Then the current setup is a specific case of turn-taking where the turn shifts after a player sends a single move (unique-reply). But generally, it does not have to be like this. Players could be allowed to send multiple messages until the turn shifts, or until they send specific speech-acts (multiple-replies). ,Timeouts in Protocols: Protocols currently do not implement the concept of timeouts. We leave it to the skill developer to implement any time-specific protocol rules. ,Framework Internal Messages: The activation/deactivation of skills and addition/removal of components is implemented in a ""passive"" way - the skill posts a request in its skill context queue (in the case of new behaviours), or it just sets a flag (in case of activation/deactivation of skills). One could consider that a skill can send requests to the framework, via the internal protocol, to modify its resources or its status. The or the can be the components that take such actions. This is a further small but meaningful step toward an actor-based model for agent internals. ,Ledger Transaction Management: Currently, the framework does not manage any aspect of submitting multiple transactions to the ledgers. This responsibility is left to skills. Additionally, the ledger APIs/contract APIs take the ledger as a reference to determine the nonce for a transaction. If a new transaction is sent before a previous transaction has been processed then the nonce will not be incremented correctly for the second transaction. This can lead to submissions of multiple transactions with the same nonce, and therefore failure of subsequent transactions. A naive approach would involve manually incrementing the nonce and then submitting transactions into the pool with the correct nonce for eventual inclusion. The problem with this approach is that any failure of a transaction will cause none of the subsequent transactions to be processed for some ledgers (<https://ethereum.stackexchange.com/questions/2808/what-happens-when-a-transaction-nonce-is-too-high>). To recover from a transaction failure not only the failed transaction would need to be handled, but potentially also all subsequent transactions. It is easy to see that logic required to recover from a transaction failure early in a sequence can be arbitrarily complex (involving potentially new negotiations between agents, new signatures having to be generated etc.). A further problem with the naive approach is that it (imperfectly) replicates the ledger state (with respect to (subset of state of) a specific account). A simple solution looks as follows: each time a transaction is constructed (requiring a new nonce) the transaction construction is queued until all previous transactions have been included in the ledger or failed. This way, at any one time the agent has only at most one transaction pending with the ledger. Benefits: simple to understand and maintain, transaction only enter the mempool when they are ready for inclusion which has privacy benefits over submitting a whole sequence of transaction at once. Downside: at most one transaction per block. This approach is currently used and implemented across all the reference skills. Related, the topic of latency in transactions. State channels provide a solution. E.g. <a href=""https://github.com/perun-network/go-perun"" target=""_blank"">Perun</a>. There could also be an interesting overlap with our protocols here. ,Unsolved Problems in - Interplay: Problem 1: connection generates too many messages in a short amount of time, that are not consumed by the multiplexer Solution: Can be solved by slowing down connections receive method called, controlled by the inbox messages amount Side effects: Most of the connections should have an internal queue because there is no synchronization between internal logic and multiplexer connection calls. Problem 2: the send method can take a long time (because send retries logic in connection) Solution: Currently, we apply timeouts on send. Other solutions could be considered, like parallelization. Problem 3: too many messages are produced by a skill. Solution: Raise an exception on outbox is full or slow down agent loop?"
Limitations of v1,ACN. documentation.
SOEF Connection,"SOEF Connection. # SOEF Connection You can use the <a href=""../simple-oef"">SOEF</a> in the agent framework by using the SOEF connection as a package in your agent project."
SOEF Connection,"Add the SOEF Package. Check out the <a href=""../cli-commands"">CLI guide</a> on details how to add a connection. You will want to add the connection package."
SOEF Connection,"Register your Agent and its Services. ,Register Agent Location: To register your agent's location, you have to send a message in the protocol to the SOEF connection. First, define a data model for location data: It is important to use this exact data model, as the SOEF connection can only process specific data models. Second, create a location object: Third, construct a service description instance with location and data model: Finally, construct a message and send it: In case everything is registered OK, you will not receive any message back. If something goes wrong you will receive an error message with performative . ,Register Personality Pieces: To register personality pieces, you have to use a specific data model: An example follows: ,Register Services: To set some service key and value you have to use a specific data model: An example follows: ,Remove Service Key: To remove service key have to use a specific data model: An example follows: !!! note Currently, the soef does not allow for multiple registrations to be combined into a single command."
SOEF Connection,"Perform a Search. To perform a search for services registered you have to define a search query consisting of constraints. The location constraints is required, personality pieces or services keys constraints are optional. An example follows: In case of error, you will receive a message with . In case of successful search you will receive a message with performative and the list of matched agents addresses."
SOEF Connection,Generic Command. To send a generic command request to the SOEF use the following (here on the example of setting a declared name):
Oracle Skills,Oracle Skills. # Oracle Skills This demo shows how an AEA can be used to maintain an oracle and how another AEA can request the oracle value.
Oracle Skills,Discussion. **Oracle agents** are agents that have permission to update or validate updates to state variables in a smart contract and whose goal is to accurately estimate or predict some real world quantity or quantities. This demonstration shows how to set up a simple oracle agent who deploys an oracle contract and updates the contract with a token price fetched from a public API. It also shows how to create an oracle client agent that can request the value from the oracle contract.
Oracle Skills,"Preparation Instructions. ,Dependencies: Follow the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start."
Oracle Skills,"Demo. ,Create the Oracle AEA: Fetch the AEA that will deploy and update the oracle contract. ??? note ""Alternatively, create from scratch (and customize the data source):"" Create the AEA that will deploy the contract. Set the URL for the data request skill: Specify the name and JSON path of the data to fetch from the API: Set the name of the oracle value in the simple oracle skill: Then update the agent configuration with the default routing: Update the default ledger. Set the following configuration for the oracle skill: This demo runs on the ledger by default. Set the following variable for use in the configuration steps: ??? note ""Alternatively, configure the agent to use an ethereum ledger:"" Update the default ledger. Set the following configuration for the oracle skill: Additionally, create the private key for the oracle AEA. Generate and add a key for use with the ledger: If running on a testnet (not including Ganache), generate some wealth for your AEA: ,Create the Oracle Client AEA: From a new terminal (in the same top-level directory), fetch the AEA that will deploy the oracle client contract and call the function that requests the coin price from the oracle contract. ??? note ""Alternatively, create from scratch:"" Create the AEA that will deploy the contract. Then update the agent configuration with the default routing: Set the default ledger: Set the following configuration for the oracle client skill: Similar to above, set a temporary variable or . ??? note ""Follow these steps to configure for an ethereum ledger:"" Set the default ledger: Set the following configuration for the oracle client skill: Create the private key for the oracle client AEA. Generate and add a key for use on the ledger: If running on a testnet (not including Ganache), generate some wealth for your AEA: ,Configuring a Ledger: The oracle AEAs require either a locally running ledger node or a connection to a remote ledger. By default, they are configured to use the latest testnet. ??? note ""Follow these steps to configure local Ethereum test node:"" The easiest way to test the oracle agents on an Ethereum-based ledger to set up a local test node using Ganache. This can be done by running the following docker command from the directory you started from (in a new terminal). This command will also fund the accounts of the AEAs: Run the following Python script (with <code>web3</code> installed) from the top-level directory to deploy a mock Fetch ERC20 contract and give some test FET to the client agent. Set the ERC20 contract address for the oracle AEA as well as for the oracle client AEA where is in the output of the script above. ,Run the Oracle AEA: Run the oracle agent. This will deploy a contract to the testnet, grant oracle permissions to the AEA's wallet address, and periodically update the contract with the latest price of FET (or whichever coin was specified). After a few moments, you should see the following notices in the logs: The oracle contract will continue to be updated with the latest retrieved coin price at the default time interval (every 15 seconds). ,Set the ERC20 and Oracle Contract Addresses for the Oracle Client AEA: where should be set to the address shown in the oracle AEA logs: ,Run the Oracle Client AEA: Run the oracle client agent. This will deploy an oracle client contract to the testnet, approve the contract to spend tokens on behalf of the AEA, and periodically call the contract function that requests the latest price of FET (or whichever coin was specified). After a few moments, you should see the following notices in the logs: The AEA will continue to request the latest coin price at the default time interval (every 15 seconds)."
Contracts,"Contracts. # Contracts <a href=""../api/contracts/base#contract-objects""></a> wrap smart contracts for Fetch.ai and third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract and its byte code. They implement a translation between framework messages (in the protocol) and the implementation specifics of the ABI. Contracts usually implement four types of methods: - a method to create a smart contract deployment transaction, - methods to create transactions to modify state in the deployed smart contract, - methods to create contract calls to execute static methods on the deployed smart contract, and - methods to query the state of the deployed smart contract. Contracts can be added as packages which means they become reusable across AEA projects. The smart contract wrapped in an AEA contract package might be a third-party smart contract or your own smart contract potentially interacting with a third-party contract on-chain."
Contracts,"Interacting with Contracts from Skills. Interacting with contracts in almost all cases requires network access. Therefore, the framework executes contract related logic in a <a href=""../connection"">Connection</a>. <img src=""../assets/message-flow-contract-ledger.jpg"" alt=""Message flow for contract and ledger interactions"" class=""center"" style=""display: block; margin-left: auto; margin-right: auto;width:80%;""> In particular, the connection can be used to execute contract related logic. The skills communicate with the connection via the protocol. This protocol implements a request-response pattern to serve the four types of methods listed above: - the message is used to request a transaction for a specific contract. For instance, to request a transaction for the deployment of the smart contract wrapped in the package, we send the following message to the : Any additional arguments needed by the contract's constructor method should be added to . This message will be handled by the connection and then a message will be returned with the matching raw transaction. To send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the connection using the protocol. For details on how to implement the message handling, see the handlers in the skill. !!! note ""CosmWasm based smart contract deployments"" When using CosmWasm based smart contracts two types of deployment transactions exist. The first transaction stores the code on the chain. The second transaction initialises the code. This way, the same contract code can be initialised many times. Both the <code>store</code> and <code>init</code> messages use the <code>ContractApiMessage.Performative.GET_DEPLOY_TRANSACTION</code> performative. The ledger API automatically detects the type of transactions based on the provided keyword arguments. In particular, an <code>init</code> transaction requires the keyword arguments <code>code_id</code> (integer), <code>label</code> (string), <code>amount</code> (integer) and <code>init_msg</code> (JSON). For an example look at the <code>fetchai/erc1155:0.23.3</code> package. - the message is used to request any transaction for a specific contract which changes state in the contract. For instance, to request a transaction for the creation of token in the deployed smart contract wrapped in the package, we send the following message to the : This message will be handled by the connection and then a message will be returned with the matching raw transaction. For this to be executed correctly, the contract package needs to implement the method with the specified key word arguments (see example in *Deploy your own*, below). Similar to the above, to send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the connection using the protocol. - the message is used to request any contract method call for a specific contract which does not change state in the contract. For instance, to request a call to get a hash from some input data in the deployed smart contract wrapped in the package, we send the following message to the : This message will be handled by the connection and then a message will be returned with the matching raw message. For this to be executed correctly, the contract package needs to implement the method with the specified key word arguments. We can then send the raw message to the connection using the protocol. In this case, signing is not required. - the message is used to request any contract method call to query state in the deployed contract. For instance, to request a call to get the balances in the deployed smart contract wrapped in the package, we send the following message to the : This message will be handled by the connection and then a message will be returned with the matching state. For this to be executed correctly, the contract package needs to implement the method with the specified key word arguments. We can then send the raw message to the connection using the protocol. In this case, signing is not required."
Contracts,"Developing your own. The easiest way to get started developing your own contract is by using the <a href=""../scaffolding"">scaffold</a> command: This will scaffold a contract package called with three files: - - , containing the scaffolded contract class - containing the scaffolded configuration file Once your scaffold is in place, you can create a folder in the package and copy the smart contract interface (e.g. bytes code and ABI) to it. Then, specify the path to the interfaces in the . For instance, if you use Ethereum, then you might specify the following: where is the ledger id and is the file containing the byte code and ABI. Finally, you will want to implement the part of the contract interface you need in : Above, we implement a method to create a transaction, in this case a transaction to create a batch of tokens. The method will be called by the framework, specifically the connection once it receives a message (see bullet point 2 above). The method first gets the latest transaction nonce of the , then constructs the contract instance, then uses the instance to build the transaction and finally updates the gas on the transaction. It helps to look at existing contract packages, like , and skills using them, like and , for inspiration and guidance."
Ledger & Crypto APIs,"Ledger & Crypto APIs. # Ledger & Crypto APIs In this section, we show you how to integrate the AEA with the Fetch.ai and third-party ledgers."
Ledger & Crypto APIs,"Ledger Support. For a ledger to be considered _supported_ in the framework, three abstract base classes need to be implemented: - the <a href=""../api/crypto/base#aea.crypto.base.LedgerApi""></a> class wraps the API to talk to the ledger and its helper methods - the <a href=""../api/crypto/base#aea.crypto.base.Crypto""></a> class wraps the API to perform cryptographic operations for the relevant ledger - the <a href=""../api/crypto/base#aea.crypto.base.FaucetApi""></a> class wraps the API to talk to a faucet on a testnet These three classes have their own registries, which allow the developer to import the relevant object where needed."
Ledger & Crypto APIs,"Ledger Plug-in Architecture. The AEA framework provides a plug-in mechanism to support ledger functionalities in an easily extendable way. At import time, the framework will load all the crypto plug-ins available in the current Python environment. A _crypto plug-in_ is a Python package which declares some specific <a href=""https://setuptools.pypa.io/en/latest/pkg_resources.html#entry-points"" target=""_blank""> ""entry points""</a> in its script. In particular, there are three types of entry points the framework looks up: - , which points to instantiable classes implementing the interface; - , which points to instantiable classes implementing the interface; - , which points to instantiable classes implementing the interface. This is an example of script for a ledger plug-in : By convention, such plug-in packages should be named , and the importable package name . In the example above, the package name is , and the importable package name is . You can search for AEA ledger plug-ins on PyPI: <a href=""https://pypi.org/search/?q=aea-ledger"" target=""_blank"">https://pypi.org/search/?q=aea-ledger</a>"
Ledger & Crypto APIs,"Maintained Plug-ins. At the moment, the framework natively supports the following three ledgers: - Fetch.ai: <a href=""https://pypi.org/project/aea-ledger-fetchai/"" target=""_blank"">PyPI package: </a>, and <a href=""https://github.com/fetchai/agents-aea/tree/main/plugins/aea-ledger-fetchai"" target=""_blank"">source code</a>. - Ethereum: <a href=""https://pypi.org/project/aea-ledger-ethereum/"" target=""_blank"">PyPI package: </a>, and <a href=""https://github.com/fetchai/agents-aea/tree/main/plugins/aea-ledger-ethereum"" target=""_blank"">source code</a>. - Cosmos: <a href=""https://pypi.org/project/aea-ledger-cosmos/"" target=""_blank"">PyPI package: </a>, and <a href=""https://github.com/fetchai/agents-aea/tree/main/plugins/aea-ledger-cosmos"" target=""_blank"">source code</a>. However, support for additional ledgers can be added to the framework at runtime."
Ledger & Crypto APIs,"Examples. of how to interact with the faucet API registry: The framework wraps all classes and exposes them in the <a href=""../api/crypto/ledger_apis#aea.crypto.base.LedgerApis""></a> classes. The framework also wraps the crypto APIs to create identities on both ledgers and exposes them in the . The separation between the and is fundamental to the framework design. In particular, the object which holds the private key is separated from the object which interacts with the ledger. This design pattern is repeated throughout the framework: the decision maker is the only entity with access to the AEA's whilst are accessible by all skills."
Ledger & Crypto APIs,"Stargate World - Fetch.ai Testnet for Agents. Stargate World is our stable, public testnet for the Fetch Ledger v2. As such, most developers will be interacting with this testnet. This is specifically designed and supported for AEA development. | Parameter | Value | |----------------|-----------------------------------------------------------------------------------------------| | Chain ID | dorado-1 | | Denomination | atestfet | | Decimals | 18 | | Version | v0.8.x | | RPC Endpoint | <https://rpc-dorado.fetch.ai:443> | | REST Endpoint | <https://rest-dorado.fetch.ai:443> | | Block Explorer | <a href=""https://explore-dorado.fetch.ai"" target=""_blank"">https://explore-dorado.fetch.ai</a> | | Token Faucet | Use block explorer | You can access more details on <a href=""https://docs.fetch.ai/ledger_v2/networks/"" target=""_blank"">docs section</a>. The configurations can be specified for the connection."
Ledger & Crypto APIs,"CosmWasm Supporting Chains. The Fetch.ai networks use <a href=""https://docs.cosmwasm.com"" target=""_blank"">CosmWasm</a> for smart contract support."
ACN Internals,"ACN Internals. # ACN Internals The aim of this document is to describe at a high-level the main implementation of the Agent Communication Network (ACN). In particular: - the <a href=""https://github.com/fetchai/agents-aea/tree/main/libs/go/libp2p_node"" target=""_blank""> Golang library</a>; - the <a href=""https://github.com/fetchai/agents-aea/tree/main/packages/fetchai/connections/p2p_libp2p"" target=""_blank""> AEA connection</a> written in Python, that implements the **direct connection** with an ACN peer; - the <a href=""https://github.com/fetchai/agents-aea/tree/main/packages/fetchai/connections/p2p_libp2p_client"" target=""_blank""> AEA connection</a> written in Python, which implements the **delegate connection** with an ACN peer. It is assumed the reader already knows what is the ACN and its purposes; if not, we suggest reading <a href=""../acn"">this page</a>. This documentation page is structured as follows: - Firstly, the ACN protocol is described: all the messages and data structures involved, as well as some example of interaction protocol with these messages; - Then, it is explained how a peer can join an existing ACN network, and the message exchange involved; - It follows the description of the journey of an envelope in the ACN network: from the agent connection to its contact peer, between ACN peers, and then from the contact peer of the destination agent to the target agent; - The following section describes the functionalities of the AEA connections that allow to communicate through the ACN: and ; - The documentation ends with a section of known issues and limitations of the current implementation."
ACN Internals,"Messages and Data Structures. ,Agent Record: An _agent record_ is a data structure containing information about an agent and its Proof-of-Representation (PoR) to be used by a peer for other peers. This data structure is used as a payload in other ACN messages (see below). The data structure contains the following fields: - : a string describing the service identifier. - : a string. It is the identifier of the ledger this agent record is associated to. Currently, the allowed values are: - , the identifier for the Fetch.AI ledger; - , the identifier for the Ethereum ledger; - , the identifier for the Cosmos ledger; - : a string. It is the public key of a public-private key pair. It is used as an identifier for routing purposes. - : a string. The representative's public key. Used in case of (PoR). - : a string. The public key of the peer. - : a string. The signature for PoR. - : a string. Specify the lower bound for certificate validity. If it is a string, it must follow the format: . It will be interpreted as time zone UTC-0 - : a string. Specify the upper bound for certificate validity. If it is a string, it must follow the format: . It will be interpreted as time zone UTC-0. ,ACN Message: Entities in the ACN (i.e. either agents or peers) exchange _ACN messages_. An ACN message contains a field, which is the actual content of the message. There are different types of payloads: - - - - - ,Status: codes greater than can be: - Generic errors: errors that occur under generic circumstances. - , with integer value : the receiver of the message does not support the protocol version of the sender; - , with integer value : the payload could not be deserialized on the receiver side; - , with integer value : an internal error; - , with integer value : a serialization error occurred on the receiving end;,Register: The payload is used to request a peer to register an agent among his known ones. The payload contains the field , which is an instance of . ,LookupRequest: The payload is sent between peer to look-up addresses in the Distributed Hash Table (DHT). It contains the agent address (a string) that the sender needs to correctly route an envelope. ,LookupResponse: The payload is the response sent by a peer that received a . It contains the associated to the requested address. ,AeaEnvelope: The payload contains the envelope sent by an agent and to be delivered to another agent. It contains: - : the envelope to be forwarded, in byte representation; - an (see above)."
ACN Internals,"ACN Protocol Interactions. ,""Registration"" Interaction: The registration interaction is used by delegate agents or relayed peers to register themselves to another peer. ,""Look-up"" Interaction: The look-up interaction is used by a peer to request information to another peer about an agent address. ,""Routing"" Interaction: The routing interaction is used by agents and peers to route the envelope through the ACN."
ACN Internals,"Joining the ACN network. ,Relay Connections: If the ACN node is configured to run the relay service, it sets up the register relay stream, waiting for registration requests. The following diagram shows an example of the message exchanged during a registration request: ,Delegate Connections: If the ACN node is configured to run the delegate service, it starts listening from a TCP socket at a configurable URI. To see a diagram of the message exchanged during a registration request read <a href=""../acn-internals#registration-interaction"" target=""_blank"">this section</a>."
ACN Internals,"ACN Transport. ,ACN Envelope Entrance: Agent -> Peer: In this section, we will describe the interaction protocols between agents and peers for the messages sent by the agent to the ACN network; in particular, the communication from the contact peer of an agent to the agent. The following diagram explains the exchange of messages on entering an envelope in the ACN. In the case of _direct connection_, is a Python process, whereas is in a separate (Golang) process. The logic of the Python Agent client is implemented in the <a href=""https://github.com/fetchai/agents-aea/tree/main/packages/fetchai/connections/p2p_libp2p"" target=""_blank"">AEA connection </a> The communication between and is done through an OS pipe for Inter-Process Communication (IPC) between the AEA's process and the libp2p node process; then, the message gets enqueued to an output queue by an input coroutine. Finally, the envelope ends up in an output queue, which is processed by an output coroutine and routed to the next peer. In the case of _delegate connection_, the message exchange is very similar; however, instead of using pipes, the communication is done through the network, i.e. TCP, with a peer which has the delegate service enabled. The logic of the client connected with a delegate connection is implemented in the <a href=""https://github.com/fetchai/agents-aea/tree/main/packages/fetchai/connections/p2p_libp2p_client"" target=""_blank"">AEA connection </a> ,ACN Envelope Routing: In this section, we describe the interaction between peers when it comes to envelope routing. Assume an envelope arrives from an agent to peer , i.e. is the first hop of the routing. Let be the local agent directly connected to , a direct peer of peer . When the envelope is leaving , we may have different scenario: 1. In case of direct connection, and the field of the envelope is not the local agent address: the message is considered invalid, and it is dropped. 2. the of the envelope is the local agent connected to the peer: the envelope is routed to the local agent. 3. the is a delegate client. Send the envelope via TCP. 4. Otherwise, look up the local DHT. If an entry is found, use it; otherwise, send a look-up request to connected peers. In particular, when a peer receives a LookupRequest message, it does the following: Let the contact peer of the recipient of the envelope. The following diagram shows how the contact peer of the envelope recipient handles the incoming envelope: ,ACN Envelope Exit: Peer -> Agent: The following diagram explains the exchange of messages on exiting an envelope in the ACN. That is, the communication from the contact peer of an agent to the agent. The same message exchange is done both in the case of direct connection and delegate connection, similarly for what has been described for the envelope entrance <a href=""../acn-internals#acn-envelope-entrance-agent-peer"">(see above)</a>."
ACN Internals,"Connect your AEA to the ACN. ,The Connection:,The Connection: The source code of the connection can be downloaded from <a href=""https://aea-registry.fetch.ai/details/connection/fetchai/p2p_libp2p_client/latest"" target=""_blank"">the main AEA framework repository.</a> or from <a href=""https://github.com/fetchai/agents-aea/tree/main/packages/fetchai/connections/p2p_libp2p_client"" target=""_blank"">the main AEA framework repository.</a> The package provides the connection class , which implements the interface and therefore can be used by the Multiplexer as any other connection. - The method of this connection will set up a TCP connection to the URI of the delegate peer. Then, it will send a request to register the agent among the peer's client connections. On registration success, it sets up the _message receiving loop_, which enqueues messages in the input queue to be read by read method calls, and the _message sending loop_, which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library . - The method and the methods behave similarly to the and methods of the <a href=""../acn-internals#the-fetchaip2p_libp2p-connection"" target=""_blank""></a>, in terms of message exchange; however, the communication is done via TCP rather than pipes. - The method interrupts the connection with the delegate peer, without explicitly unregistering."
ACN Internals,"Known Issues and Limitations. ,Delegate Client on Client Disconnection/Reconnection: In case of disconnection/reconnection, delegate client record will be removed. This can cause two problems: either the delegate client is not found, or connection is closed during the send operation. Possible solutions: - Create more complicated structure for clients storage; - Keep the delegate client record for longer; - Clean up the record by timeout, per client queues. Code references: - record removed: <a href=""https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L864"" target=""_blank"">https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L864</a> - send code: <a href=""https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L955"" target=""_blank"">https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L955</a> ,Golang Node <> Python Client Connection: In case of connection between the Golang side (i.e. ACN node) and the Python side (i.e. the AEA connection) is broken, there is no reconnection attempt. The Golang side connect to the Python server opened, but if the connection is broken Golang can try to reconnect; however, the Python side does not know about this and will restart the node completely. Possible solutions: the problem requires updates on both sides and assume possible timeouts on broken connection. If connection is broken, the Python side awaits for reconnection from Golang side, and restart node completely after timeout. ,What a Peer Should Do if it Receives an Acknowledgement with an Error?: If an ACN response is the with error code different from , the forwarding to other peers is not repeated. A possible solution is to resend the message; however, not clear why it should help in case of healthy connection, how many times the sender should retry, and how it would help. Discussion on GitHub: <a href=""https://github.com/fetchai/agents-aea/pull/2509#discussion_r642628983"" target=""_blank"">https://github.com/fetchai/agents-aea/pull/2509#discussion_r642628983</a> ,No Possibility of Switching Peers: In case of a peer becoming unavailable, a delegate client or relay client currently has no means to automatically switch the peer. In particular, the DHT should be updated when a client switches peers."
Thermometer Skills,"Thermometer Skills. # Thermometer Skills The AEA thermometer skills demonstrate an interaction between two AEAs, one purchasing temperature data from the other. - The provider of thermometer data (the ). - The buyer of thermometer data (the )."
Thermometer Skills,"Discussion. This demo aims to demonstrate how to create a very simple AEA with the usage of the AEA framework and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests the data and will deliver it to the client upon payment. To keep the demo simple, we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, the ledger interaction is only for completing a transaction."
Thermometer Skills,Communication. This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client AEA.
Thermometer Skills,"Option 1: AEA Manager Approach. ,Preparation Instructions: Install the <a href=""https://aea-manager.fetch.ai"" target=""_blank"">AEA Manager</a>. ,Demo Instructions: The following steps assume you have launched the AEA Manager Desktop app. 1. Add a new AEA called with public id . 2. Add another new AEA called with public id . 3. Copy the address from the into your clip board. Then go to the <a href=""https://explore-dorado.fetch.ai"" target=""_blank"">Dorado block explorer</a> and request some test tokens via . 4. Run the AEA. Navigate to its logs and copy the multiaddress displayed. 5. Navigate to the settings of the and under update as follows (make sure to replace the placeholder with the multiaddress): 6. Run the . In the AEA's logs, you should see the agent trading successfully."
Thermometer Skills,"Option 2: CLI Approach. ,Preparation Instructions: #### Dependencies Follow the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start. ,Demo Instructions: A demo to run the thermometer scenario with a true ledger transaction This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. #### Create Thermometer AEA First, fetch the thermometer AEA: ??? note ""Alternatively, create from scratch:"" The following steps create the thermometer AEA from scratch: #### Create Thermometer Client Then, fetch the thermometer client AEA: ??? note ""Alternatively, create from scratch:"" The following steps create the thermometer client from scratch: #### Add Keys for the Thermometer AEA First, create the private key for the thermometer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: #### Add Keys and Generate Wealth for the Thermometer Client AEA The thermometer client needs to have some wealth to purchase the thermometer information. First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai network: Next, create a private key used to secure the AEA's communications: Finally, certify the key for use by the connections that request that: #### Run both AEAs Run both AEAs from their respective terminals. First, run the thermometer AEA: Once you see a message of the form take note of the address. (Alternatively, use to retrieve the address.) This is the entry peer address for the local <a href=""../acn"">agent communication network</a> created by the thermometer AEA. Then, in the thermometer client, run this command (replace with the correct value as described above): This allows the thermometer client to connect to the same local agent communication network as the thermometer AEA. Then run the thermometer client AEA: You can see that the AEAs find each other, negotiate and eventually trade. #### Cleaning up When you're done, go up a level and delete the AEAs."
Build an AEA with the CLI,"Build an AEA with the CLI. # Build an AEA with the CLI Building an AEA step by step (ensure you have followed the <a href=""../quickstart/#preliminaries"">Preliminaries</a> and <a href=""../quickstart/#installation"">Installation</a> sections from the AEA quick start first): 1. Set up your AEA project with the CLI: 1. Look at, then add the right <a href=""../connection/"">connections</a> for your use case: , then 1. Look for, then add or generate the <a href=""../protocol/"">protocols</a> you require: , then or 1. Look for, then add or code the <a href=""../skill/"">skills</a> you need: , then . <a href=""../skill-guide/"">This guide</a> shows you step by step how to develop a skill. 1. Where required, scaffold any of the above resources with the <a href=""../scaffolding/"">scaffolding tool</a> or generate a protocol with the <a href=""../protocol-generator/"">protocol generator</a>. 1. Now, run your AEA: See information on the CLI tool <a href=""../cli-commands/"" target=""_blank"">here</a> for all the available commands."
Configurations,Configurations. # Configurations This document describes the configuration files of the different packages.
Configurations,AEA Configuration YAML. The following provides a list of the relevant regex used: The defines the AEA project. The compulsory components are listed below: aea install The can be extended with a number of optional fields: reactactsyncreactsync The can further be extended with component configuration overrides. For custom connection configurations: config For custom skill configurations:
Configurations,"Connection Configuration YAML. The , which is present in each connection package, has the following required fields: aea installtrue"
Configurations,"Contract Configuration YAML. The , which is present in each contract package, has the following required fields: aea install"
Configurations,"Protocol Configuration YAML. The , which is present in each protocol package, has the following required fields: aea install"
Configurations,"Skill Configuration YAML. The , which is present in each protocol package, has the following required fields: truefalseaea install"
Defining Data Models,"Defining Data Models. # Defining Data Models In this section, we explain how to define _data models_, an important component of the OEF Search & Discovery. It allows agents to describe themselves and to discover the services/resources they are interested in. In a sentence, a <a href=""../api/helpers/search/models#datamodel-objects""></a> is a set of , and a <a href=""../api/helpers/search/models#description-objects""></a> of a service/resource is an assignment of those attributes. All you need to specify data models and descriptions (that is, instances of the data model) can be found in the module."
Defining Data Models,Attributes. 
Defining Data Models,"Data Models. A _data model_ is just a set of _attributes_. The class that implements the data model is . **Example**: let's continue with the example of the bookshop. Once we've defined the attributes, we'd like to group them in the same structure. We can do it in the following way: A requires: 1. a _name_ (in the example the name is ) used to refer to the data model. 2. a _list of attributes_, that constitutes the abstract data model. 3. an (optional) _description_ about the purpose of the data model."
Defining Data Models,"Description. A is just an _instantiation of a data model_. That is, we specify a value to every attribute belonging to the data model we are interested in. The class that implements the description is . **Example**: now we have all we need to create a little catalogue about our books: We defined the descriptions for two books, namely and , that refers to a data model. The attributes are instantiated with a dictionary that has: - as keys, the name of the attributes. - as values, the values associated with the attributes. Notice that in the latter book we omitted the field. We are allowed to do that because of the attribute is not mandatory."
